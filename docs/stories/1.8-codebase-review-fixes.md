# Story 1.8: Codebase Review Fixes & Quality Improvements

**Status:** Draft

## User Story

As a development team, we want to address all violations, issues, and recommendations identified in the October 20, 2025 codebase review, so that we maintain professional code quality standards, meet CLAUDE.md requirements, and ensure long-term maintainability.

## Description

This story comprehensively addresses all issues identified in the codebase review document dated October 20, 2025. The review gave the project an excellent 8.5/10 rating with 92% CLAUDE.md compliance, but identified critical gaps in test coverage, minor component file length violations, and missing documentation files. This story will bring the codebase to 100% compliance with all CLAUDE.md standards and establish a solid foundation for Epic 2 development.

## Acceptance Criteria

- [ ] All API routes (8 endpoints) have comprehensive integration tests
- [ ] Critical components (Editor, FileNavigator, Auto-Save) have unit tests
- [ ] Integration tests cover authentication flow, note CRUD, and auto-save functionality
- [ ] Component file length violations are resolved (dropdown-menu, context-menu)
- [ ] `.env.example` file is created with all required environment variables documented
- [ ] shadcn/ui exception is documented in CLAUDE.md Section 1.3
- [ ] Test coverage reaches minimum 70% on critical paths (API routes, core components)
- [ ] All tests pass successfully
- [ ] No regressions in existing functionality
- [ ] TypeScript compiles without errors
- [ ] Project builds successfully with `npm run build`

## Tasks / Subtasks

### 1. Create Comprehensive API Route Tests (PRIORITY 1)
- [ ] Set up testing infrastructure for API routes
- [ ] Create `app/api/notes/route.test.ts` (GET, POST endpoints)
- [ ] Create `app/api/notes/[id]/route.test.ts` (GET, PATCH, DELETE endpoints)
- [ ] Create `app/api/folios/route.test.ts` (GET, POST endpoints)
- [ ] Create `app/api/folios/[id]/route.test.ts` (PATCH, DELETE endpoints)
- [ ] Create `app/api/folders/route.test.ts` (POST endpoint)
- [ ] Create `app/api/folders/[id]/route.test.ts` (PATCH, DELETE endpoints)
- [ ] Create `app/api/auth/signup/route.test.ts` (POST endpoint)
- [ ] Verify all tests check authentication, ownership, error handling, and response formats
- [ ] Ensure all tests use mocked Prisma client (avoid hitting real database)

### 2. Create Critical Component Unit Tests (PRIORITY 2)
- [ ] Create `components/editor/TipTapEditor.test.tsx`
- [ ] Create `components/editor/EditorView.test.tsx`
- [ ] Create `components/navigation/FileNavigator.test.tsx`
- [ ] Create `lib/hooks/useAutoSave.test.ts`
- [ ] Create `components/settings/ThemeSwitcher.test.tsx`
- [ ] Create `lib/context/ThemeContext.test.tsx`
- [ ] Verify all tests use React Testing Library best practices
- [ ] Test user interactions, not implementation details
- [ ] Verify all tests pass with `npm test`

### 3. Create Integration Tests (PRIORITY 3)
- [ ] Create `__tests__/integration/` directory
- [ ] Create `__tests__/integration/auth-flow.test.ts`
  - Test signup → login → session creation flow
  - Test protected route access without authentication
  - Test logout and session cleanup
- [ ] Create `__tests__/integration/note-crud.test.ts`
  - Test complete note lifecycle: create → read → update → delete
  - Test folio ownership verification
  - Test folder organization
- [ ] Create `__tests__/integration/auto-save.test.ts`
  - Test auto-save debouncing (500ms)
  - Test save status indicators (idle, saving, saved, error)
  - Test force save (Cmd+S / Ctrl+S)
  - Test error recovery on save failure
- [ ] Verify all integration tests pass

### 4. Resolve Component File Length Violations
- [ ] Analyze `components/ui/dropdown-menu.tsx` (257 lines, 7 over limit)
- [ ] Analyze `components/ui/context-menu.tsx` (252 lines, 2 over limit)
- [ ] Determine if splitting is appropriate or if shadcn/ui exception applies
- [ ] If exception applies, proceed to Task 5
- [ ] If splitting required, refactor into sub-component files
- [ ] Verify components still function correctly after changes
- [ ] Update imports throughout codebase if files are split

### 5. Document shadcn/ui Exception in CLAUDE.md
- [ ] Open `/Users/darrencoxon/Dropbox/Coxon team folder/coding_projects_25/edfolio/CLAUDE.md`
- [ ] Locate Section 1.3 (Component Structure)
- [ ] Add exception clause for shadcn/ui generated components
- [ ] Document that dropdown-menu (257 lines) and context-menu (252 lines) are acceptable
- [ ] Explain these are CLI-generated UI library components with multiple sub-components
- [ ] Note that custom components must still adhere to 250-line limit
- [ ] Commit CLAUDE.md changes

### 6. Create .env.example File
- [ ] Create `.env.example` in project root
- [ ] Document all required environment variables
- [ ] Include DATABASE_URL with example PostgreSQL connection string
- [ ] Include NEXTAUTH_URL with example (http://localhost:3000)
- [ ] Include NEXTAUTH_SECRET with generation instructions
- [ ] Include GOOGLE_VERTEX_AI_ENDPOINT (Europe region)
- [ ] Include GOOGLE_VERTEX_AI_PROJECT_ID
- [ ] Add descriptive comments for each variable's purpose
- [ ] Add security notes about not committing .env to git
- [ ] Verify .env is in .gitignore
- [ ] Commit .env.example to repository

### 7. Set Up Testing Infrastructure
- [ ] Verify Jest and React Testing Library are in package.json
- [ ] Install missing testing dependencies if needed
- [ ] Create `jest.config.js` with proper Next.js configuration
- [ ] Create test setup file for global test utilities
- [ ] Configure MSW (Mock Service Worker) for API mocking
- [ ] Create Prisma client mock for database tests
- [ ] Create testing utilities file with common helpers
- [ ] Update `package.json` scripts to include test commands
- [ ] Verify `npm test` runs successfully (even with 0 tests initially)

### 8. Quality Assurance & Verification
- [ ] Run all tests: `npm test`
- [ ] Verify test coverage report shows 70%+ on critical paths
- [ ] Run TypeScript compilation: `npx tsc --noEmit`
- [ ] Build project: `npm run build`
- [ ] Verify no console errors in development: `npm run dev`
- [ ] Check that all existing functionality still works
- [ ] Verify no regressions in authentication, notes, folders, or editor
- [ ] Run linter: `npm run lint`
- [ ] Fix any linting issues discovered

### 9. Update Project Documentation
- [ ] Update story file status to "Review" after all tasks complete
- [ ] Document all new test files in Dev Agent Record
- [ ] Create list of test coverage metrics
- [ ] Note any implementation decisions or trade-offs made
- [ ] Update CLAUDE.md if any additional standards clarifications are needed

### 10. Final Compliance Verification
- [ ] Run through CLAUDE.md Compliance Matrix checklist
- [ ] Verify 100% compliance (up from 92%)
- [ ] Verify Code Quality Checklist (Section 16) passes
- [ ] Verify Performance Checklist (Section 17) passes
- [ ] Document final compliance score
- [ ] Mark story as "Review" for QA Agent

## Dev Notes

### **Overview of Issues from Codebase Review**

The October 20, 2025 codebase review identified the following issues:

**HIGH PRIORITY:**
1. **Insufficient Test Coverage** - Only 2 test files in entire codebase
   - 0/8 API routes tested
   - 28/30 components untested
   - No integration tests
   - Violates CLAUDE.md Section 7.1 requirements

**MEDIUM PRIORITY:**
2. **Component File Length Violations**
   - `components/ui/dropdown-menu.tsx`: 257 lines (7 over limit)
   - `components/ui/context-menu.tsx`: 252 lines (2 over limit)
   - Violates CLAUDE.md Section 1.3 (250 line maximum)

**LOW PRIORITY:**
3. **Missing .env.example** - No documented environment variables
4. **Undocumented shadcn/ui Exception** - Should clarify if generated UI components are exempt

### **Critical Context: Test Coverage Gap**

**Current Status:**
- Only 2 test files exist: `components/navigation/NoteItem.test.tsx` and `lib/stores/folios-store.test.ts`
- This represents <10% test coverage
- CLAUDE.md Section 7.1 requires:
  - "All new components: Unit tests required"
  - "All API routes: Integration tests required"

**Impact:**
- High risk of regressions during Epic 2-4 development
- No safety net for refactoring
- Cannot confidently modify existing code
- Edge cases may go undetected until production

**Estimated Effort:** 16-24 hours for comprehensive test coverage

### **File Paths & Structure**

**New Directories to Create:**
```
__tests__/
├── integration/
│   ├── auth-flow.test.ts
│   ├── note-crud.test.ts
│   └── auto-save.test.ts
└── utils/
    ├── test-helpers.ts
    └── prisma-mock.ts
```

**New Test Files to Create (API Routes):**
```
app/api/notes/route.test.ts
app/api/notes/[id]/route.test.ts
app/api/folios/route.test.ts
app/api/folios/[id]/route.test.ts
app/api/folders/route.test.ts
app/api/folders/[id]/route.test.ts
app/api/auth/signup/route.test.ts
```

**New Test Files to Create (Components):**
```
components/editor/TipTapEditor.test.tsx
components/editor/EditorView.test.tsx
components/navigation/FileNavigator.test.tsx
components/settings/ThemeSwitcher.test.tsx
lib/hooks/useAutoSave.test.ts
lib/context/ThemeContext.test.tsx
```

**Files to Modify:**
```
CLAUDE.md - Add shadcn/ui exception to Section 1.3
package.json - Add/verify test scripts
.gitignore - Verify .env is excluded
```

**Files to Create:**
```
.env.example - Document all environment variables
jest.config.js - Jest configuration for Next.js
__tests__/setup.ts - Global test setup
__tests__/utils/test-helpers.ts - Shared test utilities
__tests__/utils/prisma-mock.ts - Prisma client mock
```

### **Testing Infrastructure Setup**

#### Required Dependencies

Verify these dependencies are in `package.json` (likely already present):
```json
{
  "devDependencies": {
    "@testing-library/react": "^14.0.0",
    "@testing-library/jest-dom": "^6.1.0",
    "@testing-library/user-event": "^14.5.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0"
  }
}
```

If missing, install with:
```bash
npm install --save-dev @testing-library/react @testing-library/jest-dom @testing-library/user-event jest jest-environment-jsdom
```

#### Jest Configuration

Create `jest.config.js`:
```javascript
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
  dir: './',
});

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/__tests__/setup.ts'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  collectCoverageFrom: [
    'app/**/*.{js,jsx,ts,tsx}',
    'components/**/*.{js,jsx,ts,tsx}',
    'lib/**/*.{js,jsx,ts,tsx}',
    '!**/*.d.ts',
    '!**/node_modules/**',
    '!**/.next/**',
    '!**/coverage/**',
    '!**/dist/**',
  ],
  testMatch: [
    '**/__tests__/**/*.[jt]s?(x)',
    '**/?(*.)+(spec|test).[jt]s?(x)',
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70,
    },
  },
};

module.exports = createJestConfig(customJestConfig);
```

#### Test Setup File

Create `__tests__/setup.ts`:
```typescript
import '@testing-library/jest-dom';

// Mock Next.js router
jest.mock('next/navigation', () => ({
  useRouter: () => ({
    push: jest.fn(),
    replace: jest.fn(),
    refresh: jest.fn(),
    back: jest.fn(),
    forward: jest.fn(),
    prefetch: jest.fn(),
  }),
  usePathname: () => '/',
  useSearchParams: () => new URLSearchParams(),
}));

// Mock NextAuth
jest.mock('next-auth/react', () => ({
  useSession: jest.fn(() => ({
    data: null,
    status: 'unauthenticated',
  })),
  SessionProvider: ({ children }: { children: React.ReactNode }) => children,
}));

// Global test utilities
global.ResizeObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  unobserve: jest.fn(),
  disconnect: jest.fn(),
}));
```

#### Prisma Mock Utility

Create `__tests__/utils/prisma-mock.ts`:
```typescript
import { PrismaClient } from '@prisma/client';
import { mockDeep, mockReset, DeepMockProxy } from 'jest-mock-extended';

jest.mock('@/lib/prisma', () => ({
  __esModule: true,
  prisma: mockDeep<PrismaClient>(),
}));

export const prismaMock = require('@/lib/prisma').prisma as DeepMockProxy<PrismaClient>;

beforeEach(() => {
  mockReset(prismaMock);
});
```

**Note:** You'll need to install `jest-mock-extended`:
```bash
npm install --save-dev jest-mock-extended
```

### **API Route Testing Pattern**

All API route tests should follow this structure:

```typescript
// app/api/notes/route.test.ts
import { NextRequest } from 'next/server';
import { GET, POST } from './route';
import { prismaMock } from '@/__tests__/utils/prisma-mock';

// Mock next-auth
jest.mock('next-auth', () => ({
  getServerSession: jest.fn(),
}));

import { getServerSession } from 'next-auth';

describe('GET /api/notes', () => {
  it('should return 401 if not authenticated', async () => {
    (getServerSession as jest.Mock).mockResolvedValue(null);

    const request = new NextRequest('http://localhost:3000/api/notes');
    const response = await GET(request);

    expect(response.status).toBe(401);
    const data = await response.json();
    expect(data.error).toBe('Unauthorized');
  });

  it('should return notes for authenticated user', async () => {
    const mockSession = {
      user: { id: 'user-123', email: 'test@example.com' },
    };
    (getServerSession as jest.Mock).mockResolvedValue(mockSession);

    const mockNotes = [
      {
        id: 'note-1',
        title: 'Test Note',
        content: {},
        folioId: 'folio-1',
        folderId: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ];

    prismaMock.note.findMany.mockResolvedValue(mockNotes);

    const request = new NextRequest('http://localhost:3000/api/notes?folioId=folio-1');
    const response = await GET(request);

    expect(response.status).toBe(200);
    const data = await response.json();
    expect(data.data).toEqual(mockNotes);
    expect(prismaMock.note.findMany).toHaveBeenCalledWith({
      where: {
        folioId: 'folio-1',
        folio: {
          ownerId: 'user-123',
        },
      },
      orderBy: { updatedAt: 'desc' },
    });
  });

  it('should return 400 if folioId is missing', async () => {
    const mockSession = {
      user: { id: 'user-123', email: 'test@example.com' },
    };
    (getServerSession as jest.Mock).mockResolvedValue(mockSession);

    const request = new NextRequest('http://localhost:3000/api/notes');
    const response = await GET(request);

    expect(response.status).toBe(400);
    const data = await response.json();
    expect(data.error).toBe('Folio ID is required');
  });

  it('should handle database errors gracefully', async () => {
    const mockSession = {
      user: { id: 'user-123', email: 'test@example.com' },
    };
    (getServerSession as jest.Mock).mockResolvedValue(mockSession);

    prismaMock.note.findMany.mockRejectedValue(new Error('Database error'));

    const request = new NextRequest('http://localhost:3000/api/notes?folioId=folio-1');
    const response = await GET(request);

    expect(response.status).toBe(500);
    const data = await response.json();
    expect(data.error).toBe('Failed to fetch notes');
  });
});

describe('POST /api/notes', () => {
  it('should create note for authenticated user', async () => {
    const mockSession = {
      user: { id: 'user-123', email: 'test@example.com' },
    };
    (getServerSession as jest.Mock).mockResolvedValue(mockSession);

    const mockNote = {
      id: 'note-1',
      title: 'New Note',
      content: {},
      folioId: 'folio-1',
      folderId: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    prismaMock.folio.findFirst.mockResolvedValue({
      id: 'folio-1',
      name: 'Test Folio',
      ownerId: 'user-123',
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    prismaMock.note.create.mockResolvedValue(mockNote);

    const request = new NextRequest('http://localhost:3000/api/notes', {
      method: 'POST',
      body: JSON.stringify({
        title: 'New Note',
        folioId: 'folio-1',
      }),
    });

    const response = await POST(request);

    expect(response.status).toBe(201);
    const data = await response.json();
    expect(data.data).toEqual(mockNote);
  });

  it('should return 403 if user does not own folio', async () => {
    const mockSession = {
      user: { id: 'user-123', email: 'test@example.com' },
    };
    (getServerSession as jest.Mock).mockResolvedValue(mockSession);

    prismaMock.folio.findFirst.mockResolvedValue(null);

    const request = new NextRequest('http://localhost:3000/api/notes', {
      method: 'POST',
      body: JSON.stringify({
        title: 'New Note',
        folioId: 'folio-1',
      }),
    });

    const response = await POST(request);

    expect(response.status).toBe(403);
    const data = await response.json();
    expect(data.error).toBe('Forbidden');
  });
});
```

**Apply this pattern to ALL 8 API endpoints:**
- Test authentication (401 without session)
- Test ownership verification (403 if user doesn't own resource)
- Test success cases (200/201 with proper data)
- Test validation errors (400 for invalid input)
- Test database errors (500 with graceful error handling)
- Test edge cases specific to each endpoint

### **Component Testing Pattern**

Use React Testing Library to test components:

```typescript
// components/editor/TipTapEditor.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { TipTapEditor } from './TipTapEditor';

describe('TipTapEditor', () => {
  it('should render editor with initial content', () => {
    const initialContent = {
      type: 'doc',
      content: [
        {
          type: 'paragraph',
          content: [{ type: 'text', text: 'Hello world' }],
        },
      ],
    };

    render(
      <TipTapEditor
        content={initialContent}
        onChange={jest.fn()}
        noteId="note-1"
      />
    );

    expect(screen.getByText('Hello world')).toBeInTheDocument();
  });

  it('should call onChange when content is modified', async () => {
    const onChange = jest.fn();
    const user = userEvent.setup();

    render(
      <TipTapEditor
        content={{ type: 'doc', content: [] }}
        onChange={onChange}
        noteId="note-1"
      />
    );

    const editor = screen.getByRole('textbox');
    await user.click(editor);
    await user.type(editor, 'New text');

    await waitFor(() => {
      expect(onChange).toHaveBeenCalled();
    });
  });

  it('should support slash commands', async () => {
    const user = userEvent.setup();

    render(
      <TipTapEditor
        content={{ type: 'doc', content: [] }}
        onChange={jest.fn()}
        noteId="note-1"
      />
    );

    const editor = screen.getByRole('textbox');
    await user.click(editor);
    await user.type(editor, '/');

    // Verify slash command menu appears
    await waitFor(() => {
      expect(screen.getByText(/heading/i)).toBeInTheDocument();
    });
  });
});
```

**Test all critical components:**
- User interactions (clicks, typing, keyboard navigation)
- Props and state changes
- Conditional rendering
- Event handlers
- Accessibility (ARIA labels, keyboard support)
- Error states

### **Integration Testing Pattern**

```typescript
// __tests__/integration/note-crud.test.ts
import { createMocks } from 'node-mocks-http';
import { GET as getNote, PATCH as updateNote, DELETE as deleteNote } from '@/app/api/notes/[id]/route';
import { POST as createNote } from '@/app/api/notes/route';
import { prismaMock } from '../utils/prisma-mock';

jest.mock('next-auth', () => ({
  getServerSession: jest.fn(),
}));

import { getServerSession } from 'next-auth';

describe('Note CRUD Integration', () => {
  const mockSession = {
    user: { id: 'user-123', email: 'test@example.com' },
  };

  beforeEach(() => {
    (getServerSession as jest.Mock).mockResolvedValue(mockSession);
  });

  it('should complete full note lifecycle: create → read → update → delete', async () => {
    // Step 1: Create note
    const createPayload = {
      title: 'Integration Test Note',
      folioId: 'folio-1',
      content: { type: 'doc', content: [] },
    };

    prismaMock.folio.findFirst.mockResolvedValue({
      id: 'folio-1',
      name: 'Test Folio',
      ownerId: 'user-123',
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    const createdNote = {
      id: 'note-123',
      ...createPayload,
      folderId: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    prismaMock.note.create.mockResolvedValue(createdNote);

    const createRequest = new NextRequest('http://localhost:3000/api/notes', {
      method: 'POST',
      body: JSON.stringify(createPayload),
    });

    const createResponse = await createNote(createRequest);
    expect(createResponse.status).toBe(201);

    // Step 2: Read note
    prismaMock.note.findFirst.mockResolvedValue(createdNote);

    const getRequest = new NextRequest('http://localhost:3000/api/notes/note-123');
    const getResponse = await getNote(getRequest, { params: { id: 'note-123' } });
    expect(getResponse.status).toBe(200);
    const getData = await getResponse.json();
    expect(getData.data.title).toBe('Integration Test Note');

    // Step 3: Update note
    const updatedNote = {
      ...createdNote,
      title: 'Updated Title',
      updatedAt: new Date(),
    };

    prismaMock.note.update.mockResolvedValue(updatedNote);

    const updateRequest = new NextRequest('http://localhost:3000/api/notes/note-123', {
      method: 'PATCH',
      body: JSON.stringify({ title: 'Updated Title' }),
    });

    const updateResponse = await updateNote(updateRequest, { params: { id: 'note-123' } });
    expect(updateResponse.status).toBe(200);
    const updateData = await updateResponse.json();
    expect(updateData.data.title).toBe('Updated Title');

    // Step 4: Delete note
    prismaMock.note.delete.mockResolvedValue(createdNote);

    const deleteRequest = new NextRequest('http://localhost:3000/api/notes/note-123', {
      method: 'DELETE',
    });

    const deleteResponse = await deleteNote(deleteRequest, { params: { id: 'note-123' } });
    expect(deleteResponse.status).toBe(200);

    // Step 5: Verify note is gone
    prismaMock.note.findFirst.mockResolvedValue(null);

    const getDeletedRequest = new NextRequest('http://localhost:3000/api/notes/note-123');
    const getDeletedResponse = await getNote(getDeletedRequest, { params: { id: 'note-123' } });
    expect(getDeletedResponse.status).toBe(404);
  });
});
```

### **.env.example File Content**

Create `.env.example`:
```bash
# Database Configuration
# PostgreSQL connection string for Prisma
# Format: postgresql://USER:PASSWORD@HOST:PORT/DATABASE
# Example: postgresql://postgres:password@localhost:5432/edfolio
DATABASE_URL="postgresql://username:password@localhost:5432/edfolio"

# NextAuth Configuration
# Base URL of your application
# Development: http://localhost:3000
# Production: https://your-domain.com
NEXTAUTH_URL="http://localhost:3000"

# NextAuth Secret
# CRITICAL: Generate a secure random string for production
# Generate with: openssl rand -base64 32
# NEVER commit your actual secret to git
NEXTAUTH_SECRET="generate-with-openssl-rand-base64-32"

# Google Vertex AI Configuration (GDPR Compliant - EU Region)
# CRITICAL: Must use Europe region for UK/EU data residency compliance
# Europe endpoint: https://europe-west2-aiplatform.googleapis.com
# DO NOT use US endpoints - GDPR violation
GOOGLE_VERTEX_AI_ENDPOINT="https://europe-west2-aiplatform.googleapis.com"

# Your Google Cloud Project ID
# Find this in Google Cloud Console
GOOGLE_VERTEX_AI_PROJECT_ID="your-gcp-project-id"

# Google Cloud Credentials (Optional - for service account authentication)
# Path to service account JSON key file
# Only needed if not using Application Default Credentials
# GOOGLE_APPLICATION_CREDENTIALS="/path/to/service-account-key.json"

# Railway Configuration (Production Only)
# Ensure Railway services are deployed to Europe region
# Verify in Railway dashboard: Settings → Region → Europe

# Security Notes:
# 1. NEVER commit .env to git (already in .gitignore)
# 2. Use strong, unique values for all secrets
# 3. Rotate secrets regularly in production
# 4. Use different values for development and production
# 5. Store production secrets in Railway environment variables
```

### **CLAUDE.md Documentation Update**

Add to Section 1.3 (Component Structure), after the "Maximum file length: 250 lines" bullet:

```markdown
### 1.3 Component Structure
- **Maximum file length:** 250 lines per component file
- **If exceeded:** Split into sub-components or extract logic to hooks/utilities
- **shadcn/ui Exception:** Components generated by the shadcn/ui CLI are exempt from the 250-line limit if they cannot be reasonably split. These are third-party UI library components with multiple exported sub-components:
  - `components/ui/dropdown-menu.tsx` (257 lines) - Acceptable
  - `components/ui/context-menu.tsx` (252 lines) - Acceptable
  - **Note:** This exception applies ONLY to shadcn/ui CLI-generated files. All custom application components must adhere to the 250-line limit.
- One component per file
- Co-locate test files with components: `Button.tsx` + `Button.test.tsx`
```

### **Package.json Scripts**

Verify these scripts exist in `package.json`:
```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest --watch",
    "test:ci": "jest --ci",
    "test:coverage": "jest --coverage",
    "test:integration": "jest --testPathPattern=__tests__/integration"
  }
}
```

### **Testing Best Practices**

1. **Test User Behavior, Not Implementation**
   - ❌ Don't test internal state or methods
   - ✅ Do test what users see and interact with

2. **Use Descriptive Test Names**
   - Format: `should [expected behavior] when [condition]`
   - Example: `should return 401 when user is not authenticated`

3. **Follow AAA Pattern**
   - **Arrange:** Set up test data and mocks
   - **Act:** Execute the code being tested
   - **Assert:** Verify the expected outcome

4. **Mock External Dependencies**
   - Mock Prisma client to avoid database hits
   - Mock NextAuth for authentication
   - Mock Next.js router and navigation
   - Mock external API calls

5. **Test Edge Cases**
   - Empty states
   - Error conditions
   - Boundary values
   - Race conditions

6. **Keep Tests Independent**
   - Each test should run in isolation
   - Don't rely on test execution order
   - Reset mocks between tests

### **Test Coverage Targets**

**Minimum Coverage (70%):**
- API Routes: 90%+ (critical for security)
- Core Components: 80%+ (Editor, FileNavigator, Auto-Save)
- Utilities: 80%+ (hooks, stores, helpers)
- UI Components: 60%+ (buttons, inputs, layouts)

**Coverage Report:**
Run `npm run test:coverage` to generate coverage report.

**Review Coverage Report:**
- Open `coverage/lcov-report/index.html` in browser
- Identify untested lines (highlighted in red)
- Prioritize testing red areas in critical paths

### **Common Testing Pitfalls to Avoid**

❌ **DON'T:**
- Test implementation details (e.g., state variable names)
- Use `any` types in test mocks
- Skip error case testing
- Test multiple things in one test
- Write tests that depend on external services
- Commit `.env` files (only `.env.example`)
- Skip test documentation

✅ **DO:**
- Test user-facing behavior
- Type all mocks properly
- Test error handling thoroughly
- Write focused, single-purpose tests
- Mock all external dependencies
- Keep `.env` in `.gitignore`
- Document complex test scenarios

### **Component File Length Decision Tree**

For `dropdown-menu.tsx` and `context-menu.tsx`:

**Question 1:** Is this a shadcn/ui CLI-generated component?
- Yes → Proceed to Question 2
- No → Must split to comply with 250-line limit

**Question 2:** Does splitting the component into separate files break functionality or maintainability?
- Yes → Document as acceptable exception in CLAUDE.md
- No → Split into sub-component files

**Question 3:** Are these components modified from original shadcn/ui generation?
- Heavily modified → Consider splitting
- Minimal modifications → Accept as exception

**Recommendation:** Both dropdown-menu and context-menu are standard shadcn/ui components with minimal customization. **Accept as exception** and document in CLAUDE.md Section 1.3.

### **Quality Checklist Before Marking "Review"**

**Testing:**
- [ ] All 8 API route files have corresponding `.test.ts` files
- [ ] All critical components have `.test.tsx` files
- [ ] Integration tests cover auth, CRUD, and auto-save
- [ ] `npm test` passes with 0 failures
- [ ] `npm run test:coverage` shows 70%+ coverage on critical paths

**Documentation:**
- [ ] `.env.example` created with all variables documented
- [ ] CLAUDE.md Section 1.3 updated with shadcn/ui exception
- [ ] All test files include descriptive comments

**Code Quality:**
- [ ] `npx tsc --noEmit` passes (TypeScript compilation)
- [ ] `npm run build` succeeds (production build)
- [ ] `npm run lint` passes (ESLint)
- [ ] No `console.log` statements in test files (use `console.error` for debugging)

**Functionality:**
- [ ] All existing features still work (no regressions)
- [ ] Authentication flow works
- [ ] Note CRUD operations work
- [ ] Auto-save works
- [ ] Theme switching works
- [ ] File navigation works

**Compliance:**
- [ ] CLAUDE.md Compliance Matrix shows 100% (up from 92%)
- [ ] All Code Quality Checklist items pass (Section 16)
- [ ] All Performance Checklist items pass (Section 17)

### **Estimated Task Breakdown**

| Task Category | Estimated Hours | Priority |
|---------------|-----------------|----------|
| API Route Tests | 12 hours | HIGH |
| Component Tests | 8 hours | HIGH |
| Integration Tests | 4-6 hours | MEDIUM |
| Testing Infrastructure | 2-3 hours | HIGH |
| Component Length Resolution | 1-2 hours | LOW |
| .env.example Creation | 0.5 hours | LOW |
| CLAUDE.md Update | 0.25 hours | LOW |
| Documentation & QA | 1-2 hours | MEDIUM |
| **TOTAL** | **28.75-33.25 hours** | - |

**At 40 hours/week:** ~1 week
**At 30 hours/week:** ~1-1.5 weeks
**At 20 hours/week:** ~1.5-2 weeks

### **Success Criteria**

This story is complete when:
1. All 8 API routes have comprehensive tests (authentication, ownership, errors, success)
2. All 6 critical components have unit tests (user interactions, props, edge cases)
3. All 3 integration test suites pass (auth flow, note CRUD, auto-save)
4. Test coverage reaches 70%+ on critical paths
5. `.env.example` exists with all variables documented
6. CLAUDE.md documents shadcn/ui exception in Section 1.3
7. `npm test` passes with 0 failures
8. `npm run build` succeeds
9. No regressions in existing functionality
10. CLAUDE.md compliance reaches 100%

### **Post-Story Benefits**

Completing this story will:
- Enable confident refactoring during Epic 2-4
- Catch regressions before they reach production
- Provide safety net for AI feature development
- Meet professional code quality standards
- Satisfy CLAUDE.md requirements
- Improve developer confidence
- Reduce debugging time
- Document expected behavior through tests
- Establish testing culture for future development

### **Dependencies**

- All required testing libraries should already be in `package.json`
- If missing, install: `npm install --save-dev jest-mock-extended @testing-library/react @testing-library/jest-dom @testing-library/user-event`
- No changes to database schema required
- No API endpoint changes required
- No UI changes required (this is purely internal quality improvement)

### **Risk Mitigation**

**Risk:** Tests might reveal existing bugs in API routes or components
**Mitigation:** Fix bugs as discovered and document in Dev Agent Record

**Risk:** Test setup might conflict with Next.js configuration
**Mitigation:** Use `next/jest` configuration helper (already standard practice)

**Risk:** Mocking Prisma might be complex
**Mitigation:** Use `jest-mock-extended` library (proven solution)

**Risk:** Integration tests might be slow
**Mitigation:** Run integration tests separately with `npm run test:integration`

**Risk:** Achieving 70% coverage might take longer than estimated
**Mitigation:** Prioritize critical paths first (API routes, core components). Lower priority components can be tested in future stories if needed.

## QA Results

_To be completed by QA Agent_

## Dev Agent Record

- Implementation Date: TBD
- All tasks completed: TBD
- All tests passing: TBD
- Files Changed: TBD

### Complete File List:

**Files Created:**
- TBD

**Files Modified:**
- TBD

### Implementation Notes:

TBD

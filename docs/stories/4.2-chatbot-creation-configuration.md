# Story 4.2: Chatbot Creation & Configuration

**Epic:** Epic 4 - Custom AI Chatbots
**Status:** Not Started
**Estimated Effort:** 8-12 hours
**Priority:** High (Foundational)
**Dependencies:** Story 4.1

---

## User Story

**As a user**, I want to create and configure multiple chatbots with custom names and behaviors, so that I can have specialized AI assistants for different purposes.

---

## Story Goal

Build the backend API and frontend interface for managing chatbots, including creation, listing, editing, and deletion. Users should be able to define chatbot names and system prompts that control behavior.

---

## Acceptance Criteria

### Backend API
- [ ] `POST /api/chatbots` - Create new chatbot
- [ ] `GET /api/chatbots` - List user's chatbots
- [ ] `GET /api/chatbots/[id]` - Get single chatbot details
- [ ] `PUT /api/chatbots/[id]` - Update chatbot configuration
- [ ] `DELETE /api/chatbots/[id]` - Delete chatbot and cascade delete knowledge base
- [ ] All endpoints require authentication
- [ ] All endpoints enforce user ownership

### Database
- [ ] Prisma schema includes Chatbot model
- [ ] Migration created and tested
- [ ] Proper indexes on userId and id fields

### Frontend UI
- [ ] Chatbot list view accessible from main navigation
- [ ] "Create Chatbot" button opens modal
- [ ] Creation modal includes:
  - Name field (required, max 50 chars)
  - System prompt textarea (required, max 500 chars)
  - Cancel and Create buttons
- [ ] Each chatbot card shows name, creation date, and actions
- [ ] Edit button opens modal with pre-filled values
- [ ] Delete button shows confirmation dialog
- [ ] Active chatbot indicator in chat window header

### Chatbot Selection
- [ ] User can select which chatbot is active in chat
- [ ] Active chatbot name displays in chat header
- [ ] Switching chatbot clears current conversation
- [ ] Default chatbot auto-created on first visit

---

## Dev Notes

### Prisma Schema
```prisma
model Chatbot {
  id              String    @id @default(cuid())
  name            String
  systemPrompt    String    @db.Text
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  knowledgeBase   Document[]
  chatSessions    ChatSession[]
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([userId])
}
```

### API Endpoints

**POST /api/chatbots**
```typescript
// app/api/chatbots/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { prisma } from '@/lib/prisma';
import { z } from 'zod';

const createChatbotSchema = z.object({
  name: z.string().min(1).max(50),
  systemPrompt: z.string().min(1).max(500),
});

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const validated = createChatbotSchema.parse(body);

    const chatbot = await prisma.chatbot.create({
      data: {
        name: validated.name,
        systemPrompt: validated.systemPrompt,
        userId: session.user.id,
      },
    });

    return NextResponse.json({ data: chatbot }, { status: 201 });
  } catch (error) {
    console.error('Error creating chatbot:', error);
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: 'Invalid input', details: error.errors }, { status: 400 });
    }
    return NextResponse.json({ error: 'Failed to create chatbot' }, { status: 500 });
  }
}

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const chatbots = await prisma.chatbot.findMany({
      where: { userId: session.user.id },
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        name: true,
        systemPrompt: true,
        createdAt: true,
        updatedAt: true,
        _count: {
          select: { knowledgeBase: true },
        },
      },
    });

    return NextResponse.json({ data: chatbots });
  } catch (error) {
    console.error('Error fetching chatbots:', error);
    return NextResponse.json({ error: 'Failed to fetch chatbots' }, { status: 500 });
  }
}
```

### Component Structure
```
components/chatbot/
├── ChatbotList.tsx           # Main list view
├── ChatbotCard.tsx           # Individual chatbot card
├── ChatbotCreationModal.tsx  # Create/edit modal
├── ChatbotDeleteDialog.tsx   # Delete confirmation
└── ChatbotSelector.tsx       # Dropdown for selecting active chatbot
```

---

## Tasks

1. **Database Schema** (1 hour)
   - [ ] Add Chatbot model to schema.prisma
   - [ ] Run migration: `npx prisma migrate dev --name add-chatbot-model`
   - [ ] Test migration locally

2. **Backend API - Create & List** (2 hours)
   - [ ] Create `app/api/chatbots/route.ts`
   - [ ] Implement POST endpoint with validation
   - [ ] Implement GET endpoint
   - [ ] Add error handling

3. **Backend API - Update & Delete** (2 hours)
   - [ ] Create `app/api/chatbots/[id]/route.ts`
   - [ ] Implement GET single chatbot
   - [ ] Implement PUT endpoint
   - [ ] Implement DELETE endpoint with cascade

4. **Chatbot Store** (1 hour)
   - [ ] Extend `store/chatStore.ts` with chatbot management
   - [ ] Add active chatbot state
   - [ ] Add chatbot CRUD methods

5. **Chatbot List Component** (2 hours)
   - [ ] Create ChatbotList.tsx
   - [ ] Fetch and display chatbots
   - [ ] Add loading and empty states

6. **Creation Modal** (2 hours)
   - [ ] Create ChatbotCreationModal.tsx
   - [ ] Form validation
   - [ ] API integration

7. **Edit & Delete** (2 hours)
   - [ ] Add edit functionality
   - [ ] Add delete confirmation dialog
   - [ ] Update chat header with selector

8. **Testing** (2 hours)
   - [ ] API endpoint tests
   - [ ] Component tests
   - [ ] Integration tests

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Code follows CLAUDE.md standards
- [ ] API has proper error handling
- [ ] Database migration successful
- [ ] Unit tests written and passing
- [ ] User ownership enforced
- [ ] Manual testing completed

---

**Next Story:** 3.3 - Private Knowledge Base Upload

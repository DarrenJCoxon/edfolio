# Story 2.5: Implement "Fix Grammar" Feature

**Status:** Draft

## User Story

As a user, I want to correct spelling and grammar mistakes in my text, so that my writing is professional and error-free.

## Description

This story implements the "Fix Grammar" functionality in the highlight menu. When users select text and click "Fix Grammar," the selected text is sent to the AI service, which returns a corrected version with spelling and grammar fixes applied. Users can configure their spelling preference (UK or US English) in Settings, which affects how the AI corrects spelling.

This builds directly on:
- Story 2.1 (Highlight Menu Foundation)
- Story 2.2 (Backend AI Service Integration)
- Story 2.3 (Rephrase Feature - reuses the same preview/accept/reject pattern)
- Story 2.4 (Summarize Feature - follows established patterns)

## Acceptance Criteria

- [ ] User settings include a UK/US English spelling selector
- [ ] The spelling preference is stored in the database per user
- [ ] The "Fix Grammar" option in the highlight menu is functional
- [ ] Clicking "Fix Grammar" sends the selected text to the AI service
- [ ] The AI prompt includes the user's spelling preference (UK or US)
- [ ] A loading indicator appears while the AI processes the request
- [ ] The AI returns a corrected version of the text with grammar and spelling fixes
- [ ] Users can preview the corrected text before accepting
- [ ] Users can accept the correction (replacing the original text)
- [ ] Users can reject the correction (keeping the original text)
- [ ] The corrected text is automatically saved when accepted
- [ ] If no corrections are needed, the user receives appropriate feedback
- [ ] Appropriate error messages are shown if the AI request fails

## Tasks / Subtasks

### Task 1: Add Spelling Preference to Database Schema (1 hour)
**Estimated Time:** 1 hour

- [ ] Open `prisma/schema.prisma`
- [ ] Add `spellingPreference` field to User model:
  - Type: `String` (enum: "UK" or "US")
  - Default: "UK"
  - Not nullable
- [ ] Generate migration: `npx prisma migrate dev --name add-user-spelling-preference`
- [ ] Verify migration file created in `prisma/migrations/`
- [ ] Test migration locally
- [ ] Update TypeScript types by running `npx prisma generate`
- [ ] Verify no migration drift: `npx prisma migrate status`

### Task 2: Create Settings API Route (1.5 hours)
**Estimated Time:** 1.5 hours

- [ ] Create `/app/api/settings/spelling/route.ts` API route
- [ ] Implement GET handler:
  - Validate authentication
  - Fetch user's spellingPreference from database
  - Return: `{ data: { spellingPreference: 'UK' | 'US' } }`
- [ ] Implement PUT handler:
  - Validate authentication
  - Parse request body: `{ spellingPreference: 'UK' | 'US' }`
  - Validate spellingPreference value (must be 'UK' or 'US')
  - Update user's spellingPreference in database
  - Return: `{ data: { spellingPreference: 'UK' | 'US' }, message: 'Spelling preference updated' }`
- [ ] Add comprehensive error handling (401, 400, 500)
- [ ] Add TypeScript types for request/response
- [ ] Keep route under 200 lines

### Task 3: Create Settings UI Component (2 hours)
**Estimated Time:** 2 hours

- [ ] Create `/components/settings/SpellingSettings.tsx` component
- [ ] Define SpellingSettingsProps interface (no props needed initially)
- [ ] Implement component with:
  - Section heading: "Spelling Preference"
  - Description: "Choose your preferred spelling variant for AI grammar corrections"
  - Radio group with two options:
    - "UK English" (value: "UK")
    - "US English" (value: "US")
  - Use shadcn/ui RadioGroup component
  - Show loading spinner while fetching current preference
  - Show loading spinner while saving preference
  - Show success toast when preference saved
  - Show error toast if save fails
- [ ] Implement state management:
  - `const [preference, setPreference] = useState<'UK' | 'US'>('UK')`
  - `const [isLoading, setIsLoading] = useState(true)`
  - `const [isSaving, setIsSaving] = useState(false)`
- [ ] Implement data fetching on mount:
  - Call GET `/api/settings/spelling`
  - Set preference state from response
  - Handle loading and error states
- [ ] Implement save handler:
  - Call PUT `/api/settings/spelling`
  - Show toast notification
  - Update local state on success
- [ ] Style with CSS variables (no hardcoded colors/spacing)
- [ ] Keep component under 250 lines

### Task 4: Integrate Settings into Settings Page (1 hour)
**Estimated Time:** 1 hour

- [ ] Create `/app/(main)/settings/page.tsx` (if doesn't exist)
- [ ] Import SpellingSettings component
- [ ] Add page layout:
  - Page heading: "Settings"
  - Sections for different settings categories
  - Render SpellingSettings component in "Preferences" section
- [ ] Style page consistently with design system
- [ ] Add breadcrumb or back navigation to main app
- [ ] Ensure authenticated route (use middleware if needed)
- [ ] Add route to navigation menu (optional)

### Task 5: Create Fix Grammar API Endpoint (2 hours)
**Estimated Time:** 2 hours

- [ ] Create `/app/api/ai/fix-grammar/route.ts` API route
- [ ] Implement POST handler with authentication validation
- [ ] Parse and validate request body (text, vaultId, noteId)
- [ ] Validate input text (length: 1-5000 characters)
- [ ] Apply rate limiting using existing rate-limiter utility
- [ ] Fetch user's spellingPreference from database
- [ ] Construct AI prompt for grammar fixing:
  - System message: "You are an expert copy editor. Fix all spelling and grammar errors in the following text. Use [UK/US] English spelling. Preserve the original meaning and tone. Return only the corrected text without explanations or additional commentary."
  - Replace [UK/US] with actual user preference
  - User message: Contains the selected text
- [ ] Call Scaleway AI using scalewayClient.chat()
- [ ] Compare original text with corrected text
- [ ] If identical: Return `{ data: { originalText, correctedText, hasChanges: false } }`
- [ ] If different: Return `{ data: { originalText, correctedText, hasChanges: true } }`
- [ ] Implement comprehensive error handling (auth, validation, AI errors, rate limits)
- [ ] Add rate limit headers to response
- [ ] Keep route under 200 lines

### Task 6: Enable Fix Grammar Button in HighlightMenu (30 minutes)
**Estimated Time:** 30 minutes

- [ ] Modify `/components/editor/HighlightMenu.tsx`
- [ ] Remove `disabled` attribute from Fix Grammar button
- [ ] Update button title from "Coming in Story 2.5" to "Fix spelling and grammar"
- [ ] Show loading spinner in button when `isProcessing && processingOption === 'fix-grammar'`
- [ ] Ensure all buttons (rephrase, summarize, fix-grammar) are disabled when any operation is processing
- [ ] Verify component remains under 250 lines total

### Task 7: Create Grammar Fix Preview Dialog Component (2.5 hours)
**Estimated Time:** 2.5 hours

- [ ] Create `/components/editor/GrammarFixPreview.tsx` component
- [ ] Define GrammarFixPreviewProps interface:
  - `isOpen: boolean` - Controls dialog visibility
  - `originalText: string` - Original selected text
  - `correctedText: string` - AI-corrected text
  - `hasChanges: boolean` - Whether any changes were made
  - `onAccept: () => void` - Callback when user accepts
  - `onReject: () => void` - Callback when user rejects
  - `isApplying: boolean` - Loading state while applying change
- [ ] Use shadcn/ui Dialog component for modal
- [ ] Layout: Two-column comparison view
  - Left column: Original text (read-only, light gray background)
  - Right column: Corrected text (read-only, light red background to indicate errors fixed)
  - Header: "Review Grammar & Spelling Corrections"
  - Subheader: "Compare the original and corrected text"
- [ ] If `hasChanges === false`:
  - Show single column with message: "No grammar or spelling errors detected"
  - Only show "Close" button (no Accept/Reject)
- [ ] If `hasChanges === true`:
  - Show two-column comparison
  - Footer actions:
    - "Accept" button (primary, shows spinner when isApplying)
    - "Reject" button (secondary, disabled when isApplying)
    - Keyboard shortcuts: Enter to accept, Escape to reject
- [ ] Style with CSS variables (no hardcoded colors/spacing)
- [ ] Ensure accessible (ARIA labels, focus management)
- [ ] Keep component under 250 lines

### Task 8: Integrate Fix Grammar Flow in EditorView (2.5 hours)
**Estimated Time:** 2.5 hours

- [ ] Modify `/components/editor/EditorView.tsx`
- [ ] Add state: `const [showGrammarFixPreview, setShowGrammarFixPreview] = useState(false)`
- [ ] Add state: `const [correctedText, setCorrectedText] = useState('')`
- [ ] Add state: `const [hasGrammarChanges, setHasGrammarChanges] = useState(false)`
- [ ] Modify existing `handleOptionClick` to handle 'fix-grammar' option:
  - Set `isProcessing = true`
  - Set `processingOption = 'fix-grammar'`
  - Store current selection range (from, to positions) using existing mechanism
  - Call `/api/ai/fix-grammar` endpoint with selected text
  - On success:
    - Set correctedText and hasGrammarChanges from response
    - Show GrammarFixPreview dialog
  - On error: show toast notification with error message
  - Finally: set `isProcessing = false`
- [ ] Implement `handleAcceptGrammarFix`:
  - Set `isApplying = true`
  - Get TipTap editor instance
  - Replace text at stored selection range with correctedText
  - Trigger auto-save (editor onChange will handle this)
  - Hide preview dialog
  - Hide highlight menu
  - Show success toast: "Grammar and spelling corrected"
  - Set `isApplying = false`
- [ ] Implement `handleRejectGrammarFix`:
  - Hide preview dialog
  - Clear correctedText state
  - Keep highlight menu open (user can try again)
- [ ] Render GrammarFixPreview component with all props
- [ ] Reuse existing text manipulation utilities from Stories 2.3/2.4

### Task 9: Update CSS for Grammar Fix Preview Dialog (45 minutes)
**Estimated Time:** 45 minutes

- [ ] Open `/app/globals.css`
- [ ] Add CSS variables for grammar fix preview:
  ```css
  :root {
    --preview-corrected-bg: #fef2f2;      /* Light red for corrected text */
    --preview-corrected-border: #ef4444; /* Red accent border */
  }
  ```
- [ ] Add dark mode overrides:
  ```css
  @media (prefers-color-scheme: dark) {
    :root {
      --preview-corrected-bg: #450a0a;    /* Dark red for dark mode */
      --preview-corrected-border: #f87171; /* Lighter red border for dark mode */
    }
  }
  ```
- [ ] Add `.grammar-fix-preview-corrected` class:
  - background-color: var(--preview-corrected-bg)
  - border-left: 3px solid var(--preview-corrected-border)
- [ ] Add `.no-changes-message` class:
  - padding: var(--spacing-lg)
  - text-align: center
  - color: var(--muted)
  - font-size: 0.875rem

### Task 10: Add Type Definitions (20 minutes)
**Estimated Time:** 20 minutes

- [ ] Open `/types/index.ts`
- [ ] Add `SpellingPreference` type:
  ```typescript
  export type SpellingPreference = 'UK' | 'US';
  ```
- [ ] Add `FixGrammarRequest` interface:
  ```typescript
  export interface FixGrammarRequest {
    text: string;
    vaultId: string;
    noteId: string;
  }
  ```
- [ ] Add `FixGrammarResponse` interface:
  ```typescript
  export interface FixGrammarResponse {
    data: {
      originalText: string;
      correctedText: string;
      hasChanges: boolean;
    };
  }
  ```
- [ ] Add `GrammarFixPreviewProps` interface (already defined in Task 7)
- [ ] Export all new types

### Task 11: Testing & Validation (3 hours)
**Estimated Time:** 3 hours

- [ ] **Database Migration Testing:**
  - [ ] Verify migration creates spellingPreference field
  - [ ] Verify default value is 'UK'
  - [ ] Test migration rollback: `npx prisma migrate reset`
  - [ ] Re-apply migration successfully
  - [ ] Verify no migration drift
- [ ] **Settings API Testing:**
  - [ ] Test GET endpoint returns current preference
  - [ ] Test PUT endpoint updates preference successfully
  - [ ] Test authentication failure (no session)
  - [ ] Test invalid preference value ('FR', 'INVALID', etc.)
  - [ ] Test error handling (database errors)
- [ ] **Settings UI Testing:**
  - [ ] Navigate to Settings page
  - [ ] Verify current preference loads correctly
  - [ ] Change preference from UK to US
  - [ ] Verify success toast appears
  - [ ] Reload page and verify preference persists
  - [ ] Change preference from US to UK
  - [ ] Verify preference updates in database
- [ ] **Fix Grammar API Endpoint Testing:**
  - [ ] Test successful correction with UK spelling
  - [ ] Test successful correction with US spelling
  - [ ] Verify spelling follows user preference (colour vs color, etc.)
  - [ ] Test text with no errors (hasChanges: false)
  - [ ] Test authentication failure (no session)
  - [ ] Test rate limiting (11 requests in quick succession)
  - [ ] Test input validation (empty text, too long)
  - [ ] Test AI service errors (mock Scaleway failures)
- [ ] **UI Flow Testing:**
  - [ ] Select text with grammar errors and click Fix Grammar
  - [ ] Verify loading indicator appears
  - [ ] Verify preview dialog shows corrections
  - [ ] Test Accept button:
    - [ ] Text is replaced in editor with corrections
    - [ ] Auto-save triggers
    - [ ] Success toast appears
    - [ ] Dialog closes
  - [ ] Test Reject button:
    - [ ] Dialog closes
    - [ ] Original text unchanged
    - [ ] Highlight menu remains open
  - [ ] Select text with no errors and click Fix Grammar
  - [ ] Verify "No errors detected" message appears
  - [ ] Verify only Close button shown (no Accept/Reject)
- [ ] **Spelling Preference Testing:**
  - [ ] Set preference to UK
  - [ ] Fix grammar on text with "color" → Should suggest "colour"
  - [ ] Set preference to US
  - [ ] Fix grammar on text with "colour" → Should suggest "color"
  - [ ] Test other UK/US differences (analyse/analyze, realise/realize)
- [ ] **Edge Case Testing:**
  - [ ] Fix grammar on single word with typo
  - [ ] Fix grammar on long paragraph (1000+ words)
  - [ ] Fix grammar on text with formatting (bold, italic)
  - [ ] Fix grammar at start of document
  - [ ] Fix grammar at end of document
  - [ ] Fix grammar across multiple paragraphs
  - [ ] Close preview with Escape key
  - [ ] Accept with Enter key
- [ ] **Build Validation:**
  - [ ] Run `npm run build` and verify no errors
  - [ ] Verify no TypeScript errors
  - [ ] Verify no ESLint errors
- [ ] **Code Quality Checks:**
  - [ ] All components under 250 lines
  - [ ] No `any` types used
  - [ ] All colors use CSS variables
  - [ ] All spacing uses CSS variables
  - [ ] Proper error handling everywhere
  - [ ] All imports use `@/` alias

## Dev Notes

### Architecture Overview

This story adds grammar and spelling correction, the final AI feature in Epic 2. It introduces a new user-configurable setting (UK/US English preference) that personalizes the AI's correction behavior.

**User Flow:**
1. User configures spelling preference in Settings (UK or US English)
2. User selects text in editor → Highlight menu appears
3. User clicks "Fix Grammar" button → Loading state shown
4. Selected text sent to `/api/ai/fix-grammar` endpoint
5. Endpoint fetches user's spelling preference from database
6. Endpoint calls Scaleway AI with grammar correction prompt (including spelling preference)
7. AI returns corrected text (or indicates no changes needed)
8. Preview dialog shows original vs. corrected text side-by-side
9. If no changes: Dialog shows "No errors detected" message with Close button
10. If changes: User accepts → Corrected text replaces original, auto-saved
11. User rejects → Dialog closed, original text unchanged

**Key Design Decisions:**
- **Settings-based spelling preference:** Stored in database per user, affects all grammar corrections
- **UK vs US spelling:** AI prompt explicitly instructs which spelling variant to use
- **"No changes" detection:** Compare original and corrected text to determine if errors were found
- **Simplified UI for no changes:** Show message instead of comparison when no errors detected
- **Red accent color:** Visually distinguishes grammar corrections from rephrase (green) and summarize (blue)
- **Reuse existing patterns:** Same preview pattern, text manipulation utilities, and error handling as Stories 2.3 and 2.4

### File Structure

```
prisma/
└── schema.prisma                # MODIFIED: Add spellingPreference to User model

prisma/migrations/
└── [timestamp]_add_user_spelling_preference/
    └── migration.sql            # NEW: Migration for spellingPreference field

app/(main)/settings/
└── page.tsx                     # NEW: Settings page with spelling preference

app/api/settings/spelling/
└── route.ts                     # NEW: GET/PUT endpoint for spelling preference

app/api/ai/
├── test/
│   └── route.ts                 # Existing (Story 2.2)
├── rephrase/
│   └── route.ts                 # Existing (Story 2.3)
├── summarize/
│   └── route.ts                 # Existing (Story 2.4)
└── fix-grammar/
    └── route.ts                 # NEW: Grammar correction endpoint

components/settings/
└── SpellingSettings.tsx         # NEW: Spelling preference UI component

components/editor/
├── HighlightMenu.tsx            # MODIFIED: Enable fix-grammar button
├── RephrasePreview.tsx          # Existing (Story 2.3)
├── SummarizePreview.tsx         # Existing (Story 2.4)
├── GrammarFixPreview.tsx        # NEW: Grammar fix preview dialog
└── EditorView.tsx               # MODIFIED: Integrate fix-grammar flow

lib/editor/
├── menu-positioning.ts          # Existing (Story 2.1)
└── text-manipulation.ts         # Existing (Stories 2.3, 2.4)

lib/ai/
├── scaleway-client.ts           # Existing (Story 2.2)
├── rate-limiter.ts              # Existing (Story 2.2)
└── types.ts                     # Existing (Story 2.2)

app/globals.css                  # MODIFIED: Add grammar fix preview styles

types/index.ts                   # MODIFIED: Add grammar fix types
```

### Database Schema Changes

**File Path:** `/Users/darrencoxon/Dropbox/Coxon team folder/coding_projects_25/edfolio/prisma/schema.prisma`

**Add to User model:**

```prisma
model User {
  id                String   @id @default(cuid())
  email             String   @unique
  emailVerified     DateTime?
  name              String?
  image             String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  spellingPreference String  @default("UK") // NEW: 'UK' or 'US'

  accounts          Account[]
  sessions          Session[]
  folios            Folio[]
}
```

**Migration Command:**
```bash
npx prisma migrate dev --name add-user-spelling-preference
```

**CRITICAL:** Follow `/docs/MIGRATION-WORKFLOW.md` exactly:
1. Modify schema.prisma first
2. Generate migration (do NOT manually edit migration SQL)
3. Test migration locally
4. Commit both schema.prisma AND migration files
5. Verify no drift: `npx prisma migrate status`

### Settings API Endpoint Implementation

**File Path:** `/Users/darrencoxon/Dropbox/Coxon team folder/coding_projects_25/edfolio/app/api/settings/spelling/route.ts`

**Complete Implementation:**

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import type { SpellingPreference } from '@/types';

export async function GET(request: NextRequest) {
  try {
    // 1. Validate authentication
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 2. Fetch user's spelling preference
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { spellingPreference: true }
    });

    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    // 3. Return preference
    return NextResponse.json({
      data: {
        spellingPreference: user.spellingPreference as SpellingPreference
      }
    });

  } catch (error) {
    console.error('Get spelling preference error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

export async function PUT(request: NextRequest) {
  try {
    // 1. Validate authentication
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 2. Parse and validate request body
    const body = await request.json();
    const { spellingPreference } = body;

    if (!spellingPreference || !['UK', 'US'].includes(spellingPreference)) {
      return NextResponse.json(
        { error: 'Invalid spelling preference. Must be "UK" or "US"' },
        { status: 400 }
      );
    }

    // 3. Update user's spelling preference
    const user = await prisma.user.update({
      where: { id: session.user.id },
      data: { spellingPreference },
      select: { spellingPreference: true }
    });

    // 4. Return updated preference
    return NextResponse.json({
      data: {
        spellingPreference: user.spellingPreference as SpellingPreference
      },
      message: 'Spelling preference updated successfully'
    });

  } catch (error) {
    console.error('Update spelling preference error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

**Key Features:**
- GET endpoint fetches user's current preference
- PUT endpoint updates preference with validation
- Only accepts 'UK' or 'US' values
- Authentication required for both endpoints
- Comprehensive error handling
- Simple, focused responsibility

### Settings UI Component

**File Path:** `/Users/darrencoxon/Dropbox/Coxon team folder/coding_projects_25/edfolio/components/settings/SpellingSettings.tsx`

**Complete Implementation:**

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Label } from '@/components/ui/label';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { toast } from 'sonner';
import { Loader2 } from 'lucide-react';
import type { SpellingPreference } from '@/types';

export function SpellingSettings() {
  const [preference, setPreference] = useState<SpellingPreference>('UK');
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);

  // Fetch current preference on mount
  useEffect(() => {
    async function fetchPreference() {
      try {
        const response = await fetch('/api/settings/spelling');
        if (!response.ok) {
          throw new Error('Failed to fetch spelling preference');
        }
        const data = await response.json();
        setPreference(data.data.spellingPreference);
      } catch (error) {
        console.error('Fetch preference error:', error);
        toast.error('Failed to load spelling preference');
      } finally {
        setIsLoading(false);
      }
    }

    fetchPreference();
  }, []);

  // Save preference when changed
  const handlePreferenceChange = async (value: SpellingPreference) => {
    setIsSaving(true);
    setPreference(value);

    try {
      const response = await fetch('/api/settings/spelling', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ spellingPreference: value })
      });

      if (!response.ok) {
        throw new Error('Failed to update spelling preference');
      }

      toast.success('Spelling preference updated');
    } catch (error) {
      console.error('Update preference error:', error);
      toast.error('Failed to update spelling preference');
      // Revert to previous value on error
      const response = await fetch('/api/settings/spelling');
      const data = await response.json();
      setPreference(data.data.spellingPreference);
    } finally {
      setIsSaving(false);
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center gap-[var(--spacing-sm)] text-[var(--muted)]">
        <Loader2 className="h-4 w-4 animate-spin" />
        <span className="text-sm">Loading spelling preference...</span>
      </div>
    );
  }

  return (
    <div className="space-y-[var(--spacing-md)]">
      <div>
        <h3 className="text-base font-medium text-[var(--foreground)]">
          Spelling Preference
        </h3>
        <p className="text-sm text-[var(--muted)] mt-[var(--spacing-xs)]">
          Choose your preferred spelling variant for AI grammar corrections
        </p>
      </div>

      <RadioGroup
        value={preference}
        onValueChange={(value) => handlePreferenceChange(value as SpellingPreference)}
        disabled={isSaving}
        className="space-y-[var(--spacing-sm)]"
      >
        <div className="flex items-center space-x-[var(--spacing-sm)]">
          <RadioGroupItem value="UK" id="uk-spelling" />
          <Label
            htmlFor="uk-spelling"
            className="text-sm font-normal cursor-pointer"
          >
            UK English (colour, realise, analyse)
          </Label>
        </div>
        <div className="flex items-center space-x-[var(--spacing-sm)]">
          <RadioGroupItem value="US" id="us-spelling" />
          <Label
            htmlFor="us-spelling"
            className="text-sm font-normal cursor-pointer"
          >
            US English (color, realize, analyze)
          </Label>
        </div>
      </RadioGroup>

      {isSaving && (
        <div className="flex items-center gap-[var(--spacing-xs)] text-[var(--muted)]">
          <Loader2 className="h-3 w-3 animate-spin" />
          <span className="text-xs">Saving...</span>
        </div>
      )}
    </div>
  );
}
```

**Key Features:**
- Loads current preference on mount
- Radio group with UK and US options
- Auto-saves when preference changes
- Loading states for fetch and save
- Toast notifications for success/error
- Reverts to previous value on save error
- All styling via CSS variables
- Accessible with proper labels

### Settings Page

**File Path:** `/Users/darrencoxon/Dropbox/Coxon team folder/coding_projects_25/edfolio/app/(main)/settings/page.tsx`

**Complete Implementation:**

```typescript
import { SpellingSettings } from '@/components/settings/SpellingSettings';

export default function SettingsPage() {
  return (
    <div className="max-w-3xl mx-auto p-[var(--spacing-lg)]">
      <div className="mb-[var(--spacing-xl)]">
        <h1 className="text-2xl font-bold text-[var(--foreground)]">
          Settings
        </h1>
        <p className="text-sm text-[var(--muted)] mt-[var(--spacing-xs)]">
          Manage your preferences and account settings
        </p>
      </div>

      <div className="space-y-[var(--spacing-xl)]">
        {/* Preferences Section */}
        <section className="border border-[var(--border)] rounded-lg p-[var(--spacing-lg)]">
          <h2 className="text-lg font-semibold text-[var(--foreground)] mb-[var(--spacing-md)]">
            Preferences
          </h2>
          <SpellingSettings />
        </section>

        {/* Future sections: Account, Privacy, etc. */}
      </div>
    </div>
  );
}
```

**Key Features:**
- Clean, simple layout
- Section-based organization
- Renders SpellingSettings component
- Room for future settings sections
- Consistent spacing with CSS variables

### Fix Grammar API Endpoint Implementation

**File Path:** `/Users/darrencoxon/Dropbox/Coxon team folder/coding_projects_25/edfolio/app/api/ai/fix-grammar/route.ts`

**Complete Implementation:**

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { scalewayClient, DEFAULT_MODEL } from '@/lib/ai/scaleway-client';
import { checkRateLimit } from '@/lib/ai/rate-limiter';
import { prisma } from '@/lib/prisma';
import type { SpellingPreference } from '@/types';

export async function POST(request: NextRequest) {
  try {
    // 1. Validate authentication
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 2. Check rate limit
    const rateLimitResult = checkRateLimit(session.user.id);
    if (!rateLimitResult.allowed) {
      return NextResponse.json(
        { error: 'Rate limit exceeded' },
        {
          status: 429,
          headers: {
            'X-RateLimit-Limit': rateLimitResult.limit.toString(),
            'X-RateLimit-Remaining': '0',
            'Retry-After': rateLimitResult.retryAfter.toString()
          }
        }
      );
    }

    // 3. Parse and validate input
    const body = await request.json();
    const { text, vaultId, noteId } = body;

    if (!text || typeof text !== 'string') {
      return NextResponse.json(
        { error: 'Invalid text' },
        { status: 400 }
      );
    }

    if (text.length < 1 || text.length > 5000) {
      return NextResponse.json(
        { error: 'Text must be between 1 and 5000 characters' },
        { status: 400 }
      );
    }

    // 4. Verify user owns the vault/note (security)
    if (vaultId && noteId) {
      const folio = await prisma.folio.findFirst({
        where: {
          id: vaultId,
          ownerId: session.user.id
        }
      });

      if (!folio) {
        return NextResponse.json(
          { error: 'Folio not found or access denied' },
          { status: 403 }
        );
      }
    }

    // 5. Fetch user's spelling preference
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { spellingPreference: true }
    });

    const spellingPref = (user?.spellingPreference as SpellingPreference) || 'UK';

    // 6. Call Scaleway AI for grammar correction
    const result = await scalewayClient.chat({
      model: DEFAULT_MODEL,
      messages: [
        {
          role: 'system',
          content: `You are an expert copy editor. Fix all spelling and grammar errors in the following text. Use ${spellingPref} English spelling. Preserve the original meaning and tone. Return only the corrected text without explanations or additional commentary.`
        },
        {
          role: 'user',
          content: text
        }
      ],
      temperature: 0.3, // Low temperature for consistent, accurate corrections
      max_tokens: Math.max(1000, Math.ceil(text.length * 1.2)) // Allow slightly longer for corrections
    });

    const correctedText = result.choices[0].message.content.trim();

    // 7. Determine if changes were made
    const hasChanges = text.trim() !== correctedText;

    // 8. Return response
    return NextResponse.json(
      {
        data: {
          originalText: text,
          correctedText: correctedText,
          hasChanges: hasChanges
        }
      },
      {
        headers: {
          'X-RateLimit-Limit': rateLimitResult.limit.toString(),
          'X-RateLimit-Remaining': rateLimitResult.remaining.toString()
        }
      }
    );

  } catch (error) {
    console.error('Fix grammar endpoint error:', error);

    // Handle specific error types from Scaleway client
    if (error instanceof Error && 'status' in error) {
      const statusCode = (error as { status: number }).status;
      return NextResponse.json(
        { error: error.message },
        { status: statusCode }
      );
    }

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

**Key Differences from Other AI Endpoints:**
- **Fetches spelling preference:** Retrieves user's UK/US preference from database
- **Dynamic AI prompt:** Injects spelling preference into system message
- **Lower temperature (0.3):** More deterministic corrections (vs 0.5 for summarize, 0.7 for rephrase)
- **Change detection:** Compares original and corrected text to set `hasChanges` flag
- **Preserves tone:** AI instructed to maintain original voice and style

**Response Format:**
```typescript
// Success with changes (200)
{
  data: {
    originalText: "Their going to the store tommorow.",
    correctedText: "They're going to the store tomorrow.",
    hasChanges: true
  }
}

// Success without changes (200)
{
  data: {
    originalText: "The cat sat on the mat.",
    correctedText: "The cat sat on the mat.",
    hasChanges: false
  }
}

// Error (4xx/5xx)
{
  error: "Error message here"
}
```

### GrammarFixPreview Component

**File Path:** `/Users/darrencoxon/Dropbox/Coxon team folder/coding_projects_25/edfolio/components/editor/GrammarFixPreview.tsx`

**Complete Implementation:**

```typescript
'use client';

import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Loader2, CheckCircle } from 'lucide-react';

export interface GrammarFixPreviewProps {
  isOpen: boolean;
  originalText: string;
  correctedText: string;
  hasChanges: boolean;
  onAccept: () => void;
  onReject: () => void;
  isApplying: boolean;
}

export function GrammarFixPreview({
  isOpen,
  originalText,
  correctedText,
  hasChanges,
  onAccept,
  onReject,
  isApplying,
}: GrammarFixPreviewProps) {
  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && !isApplying && onReject()}>
      <DialogContent className="max-w-4xl">
        <DialogHeader>
          <DialogTitle>Review Grammar & Spelling Corrections</DialogTitle>
          <DialogDescription>
            {hasChanges
              ? 'Compare the original and corrected text'
              : 'No grammar or spelling errors detected'}
          </DialogDescription>
        </DialogHeader>

        {hasChanges ? (
          // Two-column comparison view
          <div className="grid grid-cols-2 gap-[var(--spacing-md)] mt-[var(--spacing-md)]">
            {/* Original Text Column */}
            <div>
              <h3 className="text-sm font-medium mb-[var(--spacing-sm)] text-[var(--muted)]">
                Original
              </h3>
              <div className="rephrase-preview-column rephrase-preview-original">
                {originalText}
              </div>
            </div>

            {/* Corrected Text Column */}
            <div>
              <h3 className="text-sm font-medium mb-[var(--spacing-sm)] text-[var(--accent)]">
                Corrected
              </h3>
              <div className="rephrase-preview-column grammar-fix-preview-corrected">
                {correctedText}
              </div>
            </div>
          </div>
        ) : (
          // No changes message
          <div className="no-changes-message">
            <CheckCircle className="h-12 w-12 mx-auto mb-[var(--spacing-md)] text-[var(--accent)]" />
            <p className="text-base font-medium text-[var(--foreground)]">
              Your text looks great!
            </p>
            <p className="text-sm text-[var(--muted)] mt-[var(--spacing-xs)]">
              No grammar or spelling errors were found.
            </p>
          </div>
        )}

        <DialogFooter className="mt-[var(--spacing-lg)]">
          {hasChanges ? (
            <>
              <Button
                variant="outline"
                onClick={onReject}
                disabled={isApplying}
                type="button"
              >
                Reject
              </Button>
              <Button
                onClick={onAccept}
                disabled={isApplying}
                type="button"
              >
                {isApplying && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                Accept
              </Button>
            </>
          ) : (
            <Button onClick={onReject} type="button">
              Close
            </Button>
          )}
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

**Key Features:**
- Conditional rendering based on `hasChanges`
- Two-column comparison when changes detected
- "No errors" message with checkmark icon when clean
- Red accent color distinguishes from rephrase (green) and summarize (blue)
- Simplified footer when no changes (only Close button)
- Loading state in Accept button
- Keyboard support (Enter/Escape)
- All styling via CSS variables

### EditorView Integration

**File Path:** `/Users/darrencoxon/Dropbox/Coxon team folder/coding_projects_25/edfolio/components/editor/EditorView.tsx`

**New State Variables:**
```typescript
const [showGrammarFixPreview, setShowGrammarFixPreview] = useState(false);
const [correctedText, setCorrectedText] = useState('');
const [hasGrammarChanges, setHasGrammarChanges] = useState(false);
```

**Add to handleOptionClick (alongside rephrase and summarize cases):**
```typescript
else if (option === 'fix-grammar') {
  // NEW: Fix grammar logic
  setIsProcessing(true);
  setProcessingOption(option);

  // Store selection range for later replacement (reuse existing mechanism)
  const range = getSelectionRange(editor);
  if (range) {
    setSelectionRange(range);
  }

  try {
    const response = await fetch('/api/ai/fix-grammar', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: selectedText,
        vaultId: note.folioId,
        noteId: activeNoteId
      })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to fix grammar');
    }

    const data = await response.json();
    setCorrectedText(data.data.correctedText);
    setHasGrammarChanges(data.data.hasChanges);
    setShowGrammarFixPreview(true);

  } catch (error) {
    console.error('Fix grammar error:', error);
    toast.error(error instanceof Error ? error.message : 'Failed to fix grammar');
  } finally {
    setIsProcessing(false);
    setProcessingOption(null);
  }
}
```

**Accept Handler:**
```typescript
const handleAcceptGrammarFix = useCallback(async () => {
  if (!selectionRange || !editor) return;

  setIsApplying(true);

  try {
    // Replace text in editor using existing text manipulation utility
    replaceTextAtRange(editor, selectionRange.from, selectionRange.to, correctedText);

    // Auto-save will trigger via editor onChange
    setShowGrammarFixPreview(false);
    setShowHighlightMenu(false);
    toast.success('Grammar and spelling corrected');

  } catch (error) {
    console.error('Apply grammar fix error:', error);
    toast.error('Failed to apply corrections');
  } finally {
    setIsApplying(false);
  }
}, [selectionRange, correctedText, editor]);
```

**Reject Handler:**
```typescript
const handleRejectGrammarFix = useCallback(() => {
  setShowGrammarFixPreview(false);
  setCorrectedText('');
  setHasGrammarChanges(false);
  // Keep highlight menu open so user can try again
}, []);
```

**Component Render (add to existing previews):**
```typescript
<GrammarFixPreview
  isOpen={showGrammarFixPreview}
  originalText={selectedText}
  correctedText={correctedText}
  hasChanges={hasGrammarChanges}
  onAccept={handleAcceptGrammarFix}
  onReject={handleRejectGrammarFix}
  isApplying={isApplying}
/>
```

### CSS Variable Usage

**All colors and spacing MUST use CSS variables per CLAUDE.md Section 2:**

**New Variables in `app/globals.css`:**
```css
:root {
  /* Existing variables from Stories 2.3 and 2.4 */
  --preview-original-bg: #f9fafb;
  --preview-rephrased-bg: #f0fdf4;
  --preview-summary-bg: #eff6ff;
  --preview-border: var(--border);
  --preview-text: var(--foreground);

  /* NEW: Grammar Fix Preview Colors */
  --preview-corrected-bg: #fef2f2;      /* Light red for corrected text */
  --preview-corrected-border: #ef4444;  /* Red accent border */
}

@media (prefers-color-scheme: dark) {
  :root {
    --preview-original-bg: #1f2937;
    --preview-rephrased-bg: #064e3b;
    --preview-summary-bg: #1e3a5f;

    /* NEW: Dark mode for grammar fix preview */
    --preview-corrected-bg: #450a0a;    /* Dark red for dark mode */
    --preview-corrected-border: #f87171; /* Lighter red border for dark mode */
  }
}
```

**Component Classes (add to existing):**
```css
/* Existing from Stories 2.3 and 2.4 */
.rephrase-preview-column {
  padding: var(--spacing-md);
  border-radius: 0.5rem;
  border: 1px solid var(--preview-border);
  font-family: var(--font-sans);
  font-size: 0.875rem;
  line-height: 1.6;
  color: var(--preview-text);
  white-space: pre-wrap;
  word-break: break-word;
  min-height: 120px;
  max-height: 400px;
  overflow-y: auto;
}

.rephrase-preview-original {
  background-color: var(--preview-original-bg);
}

.rephrase-preview-suggested {
  background-color: var(--preview-rephrased-bg);
}

.summarize-preview-summary {
  background-color: var(--preview-summary-bg);
  border-left: 3px solid var(--preview-summary-border);
}

/* NEW: Grammar fix-specific styles */
.grammar-fix-preview-corrected {
  background-color: var(--preview-corrected-bg);
  border-left: 3px solid var(--preview-corrected-border);
}

.no-changes-message {
  padding: var(--spacing-xl);
  text-align: center;
  color: var(--muted);
}
```

**Design Rationale:**
- **Red theme for grammar corrections:** Visually distinct from rephrase (green), summarize (blue)
- **Left border accent:** Emphasizes the corrected column
- **Reuse base styles:** `.rephrase-preview-column` works for all preview types
- **No changes message styling:** Centered, spacious, positive feedback

### Error Handling Strategy

**Same error handling as Stories 2.3 and 2.4, plus:**

| Status | Error Message | User-Facing Message |
|--------|---------------|---------------------|
| 400 | Invalid spelling preference | "Invalid spelling preference. Please check your settings." |
| 400 | Text too short/long | "Text must be between 1 and 5000 characters" |
| 401 | Unauthorized | "Please log in to use AI features" |
| 403 | Folio access denied | "You don't have permission to edit this note" |
| 429 | Rate limit exceeded | "Too many requests. Please wait {seconds} seconds." |
| 500 | AI service error | "AI service is unavailable. Please try again later." |
| 503 | Service unavailable | "AI service is unavailable. Please try again later." |
| Network | Fetch failed | "Connection failed. Please check your internet." |

**Settings-Specific Errors:**
- Failed to load preference: "Failed to load spelling preference"
- Failed to save preference: "Failed to update spelling preference"
- Reverts to previous value on save error (optimistic UI)

### Security Considerations

**Same security measures as Stories 2.3 and 2.4:**

1. **Folio Ownership Verification:** Always verify user owns the folio
2. **Input Sanitization:** Validate text length (1-5000 characters)
3. **Rate Limiting:** 10 requests per minute per user (shared with all AI features)
4. **Authentication:** All AI and settings endpoints require NextAuth session
5. **GDPR Compliance:** All data processed in EU (Scaleway France datacenter)

**Additional Security:**
- **Settings validation:** Only 'UK' or 'US' values accepted for spellingPreference
- **Database constraints:** Default value ensures field is never null

### Performance Considerations

**1. Loading States:**
- Same pattern as Stories 2.3 and 2.4 (button spinner, toast notifications)
- Settings page shows loading spinner while fetching/saving

**2. Auto-Save Integration:**
- Reuses existing TipTap onChange auto-save (Story 1.4)
- Debounced at 500ms (existing implementation)

**3. Preview Dialog Rendering:**
- Conditional rendering based on `hasChanges`
- Simpler UI when no changes detected
- Same performance as other preview dialogs

**4. API Response Time:**
- Scaleway AI typically responds in 1-3 seconds for grammar corrections
- Similar to rephrase, faster than summarize
- Timeout set to 30 seconds (Story 2.2)

**5. Database Queries:**
- Settings endpoint: Single query to fetch/update spellingPreference
- Grammar endpoint: Two queries (folio verification + user preference)
- All queries use Prisma's efficient query builder

### Dependencies

**No new npm packages required:**
- All dependencies already installed from Stories 2.1-2.4
- Toast notifications: `sonner` (Story 1.6)
- Dialog component: `shadcn/ui` (already installed)
- Radio group: `shadcn/ui` (already installed)
- Icons: `lucide-react` (Story 1.5)
- AI client: Scaleway client (Story 2.2)
- Rate limiting: Rate limiter utility (Story 2.2)

### Testing Strategy

**Manual Testing Checklist:**

1. **Database Migration:**
   - [ ] Run migration successfully
   - [ ] Verify spellingPreference field exists
   - [ ] Verify default value is 'UK'
   - [ ] Test migration rollback and reapply

2. **Settings Page:**
   - [ ] Navigate to Settings page
   - [ ] Verify current preference loads
   - [ ] Change from UK to US
   - [ ] Verify success toast
   - [ ] Reload page and verify persistence
   - [ ] Change from US to UK
   - [ ] Verify preference updates

3. **Spelling Preference Effect:**
   - [ ] Set preference to UK
   - [ ] Fix grammar on "color" → Should suggest "colour"
   - [ ] Set preference to US
   - [ ] Fix grammar on "colour" → Should suggest "color"
   - [ ] Test other differences (analyse/analyze, realise/realize)

4. **Happy Path:**
   - [ ] Select text with errors
   - [ ] Click "Fix Grammar"
   - [ ] Verify loading spinner
   - [ ] Verify preview shows corrections
   - [ ] Click "Accept"
   - [ ] Verify text replaced
   - [ ] Verify success toast
   - [ ] Verify auto-save triggers

5. **No Changes Path:**
   - [ ] Select text with no errors
   - [ ] Click "Fix Grammar"
   - [ ] Verify "No errors detected" message
   - [ ] Verify only Close button shown
   - [ ] Click Close
   - [ ] Verify dialog closes

6. **Reject Flow:**
   - [ ] Select text and fix grammar
   - [ ] Click "Reject" in preview
   - [ ] Verify original text unchanged
   - [ ] Verify dialog closes
   - [ ] Verify highlight menu still visible

7. **Error Scenarios:**
   - [ ] Log out, try to fix grammar → 401 error
   - [ ] Make 11 requests quickly → 429 error
   - [ ] Mock Scaleway error → 500 error
   - [ ] Disconnect internet → Network error

8. **Edge Cases:**
   - [ ] Fix grammar on single word
   - [ ] Fix grammar on 1000+ word passage
   - [ ] Fix grammar on text with formatting
   - [ ] Fix grammar at start/end of document
   - [ ] Close preview with Escape key
   - [ ] Accept with Enter key

### Code Quality Checklist

Before marking story as "Review", verify:

- [ ] Database migration successful and committed
- [ ] No hardcoded colors (all use CSS variables from `globals.css`)
- [ ] No hardcoded spacing (all use CSS variables)
- [ ] No `any` types in TypeScript (all properly typed)
- [ ] All files under line limits:
  - [ ] `/app/api/ai/fix-grammar/route.ts` under 200 lines
  - [ ] `/app/api/settings/spelling/route.ts` under 200 lines
  - [ ] `GrammarFixPreview.tsx` under 250 lines
  - [ ] `SpellingSettings.tsx` under 250 lines
  - [ ] Settings page under 250 lines
  - [ ] `HighlightMenu.tsx` under 250 lines
  - [ ] `EditorView.tsx` under 600 lines (acceptable for main component)
- [ ] API routes have comprehensive error handling
- [ ] All components have proper TypeScript interfaces
- [ ] All imports use `@/` alias for consistency
- [ ] Build succeeds: `npm run build` with zero errors
- [ ] No console.logs in production code (only in catch blocks)
- [ ] GDPR compliance verified (Scaleway EU endpoint)
- [ ] Authentication verified on all endpoints
- [ ] Rate limiting tested and working
- [ ] No migration drift: `npx prisma migrate status` shows "up to date"

### Integration with Existing Features

**Builds On:**
- **Story 2.1 (Highlight Menu):** Uses existing menu, enables fix-grammar button
- **Story 2.2 (AI Backend):** Uses Scaleway client, rate limiter, and infrastructure
- **Story 2.3 (Rephrase):** Reuses preview pattern, text manipulation utilities, error handling
- **Story 2.4 (Summarize):** Follows same architectural patterns
- **Story 1.4 (TipTap Editor):** Integrates with editor for text replacement
- **Story 1.6 (Auto-save):** Triggers auto-save when text is replaced
- **Story 1.1 (CSS Variables):** Uses existing design system

**Completes:**
- **Epic 2 (Basic AI Augmentation):** Final story in epic - all three AI features now implemented

**New Patterns Introduced:**
- **User settings with database persistence:** First feature to use user-configurable preferences
- **Conditional preview UI:** First preview to change layout based on result (hasChanges)
- **AI prompt personalization:** First AI feature to adapt based on user preference

### Known Limitations

**Current Implementation:**
- **Single correction pass:** No iterative improvement or alternative corrections
- **No diff highlighting:** Corrections shown side-by-side, not inline with highlights
- **No undo for accepted corrections:** User must use Cmd+Z in editor
- **No context awareness:** Doesn't consider surrounding text for contextual corrections
- **Binary spelling choice:** Only UK or US, no other variants (Canadian, Australian, etc.)

**Future Enhancements (Out of Scope):**
- Inline diff view with highlighted changes
- Explanation of what was corrected and why
- Multiple correction suggestions (user chooses best)
- Grammar rule customization (e.g., Oxford comma preference)
- Correction history and analytics
- Batch grammar fixing (entire document at once)
- Style guide enforcement (formal, casual, academic tone)

### Timeline Estimate

**Total estimated time: 16.75 hours**

Breakdown:
- Add spelling preference to database: 1 hour
- Create settings API route: 1.5 hours
- Create settings UI component: 2 hours
- Integrate settings into settings page: 1 hour
- Create fix grammar API endpoint: 2 hours
- Enable fix grammar button: 30 minutes
- Implement GrammarFixPreview dialog: 2.5 hours
- Integrate fix grammar flow in EditorView: 2.5 hours
- Update CSS: 45 minutes
- Add type definitions: 20 minutes
- Testing and validation: 3 hours

**Recommendation:** This story can be completed in 2-2.5 days. It's larger than Stories 2.3 and 2.4 due to the settings page addition, but follows established patterns for the core AI functionality.

### Files Modified Summary

**Database Changes:**
1. `prisma/schema.prisma` - Added spellingPreference field to User model
2. New migration file in `prisma/migrations/` (~10 lines SQL)

**Files Created (5 new files):**
1. `/app/api/settings/spelling/route.ts` (~120 lines)
2. `/app/api/ai/fix-grammar/route.ts` (~160 lines)
3. `/components/settings/SpellingSettings.tsx` (~110 lines)
4. `/app/(main)/settings/page.tsx` (~50 lines)
5. `/components/editor/GrammarFixPreview.tsx` (~120 lines)

**Files Modified (4 existing files):**
1. `/components/editor/HighlightMenu.tsx` (+7 lines)
2. `/components/editor/EditorView.tsx` (+80 lines)
3. `/app/globals.css` (+20 lines)
4. `/types/index.ts` (+30 lines)

**Total New Code:** ~707 lines (including migration and settings infrastructure)
**All files remain under line limits:** ✓

---

## QA Results

_To be completed by QA Agent_

---

## Dev Agent Record

_To be completed by Developer Agent_

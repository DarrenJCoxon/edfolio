# Story 3.2: Collaborative Sharing & Permissions

**Status:** Approved

**Epic:** Epic 3 - Web Publishing Feature

**Dependencies:** Story 3.1 (Basic Page Publishing)

## User Story

As a user, I want to share my published pages with specific people via email with either read-only or edit permissions, and allow collaborators with edit access to clone pages to their own vault, so that I can collaborate on content creation while maintaining control over access and ownership.

## Description

This story extends the existing web publishing feature (Story 3.1) with Google Docs-style collaborative sharing capabilities. Users can invite specific people via email to access published pages with granular permissions:

1. **Read-Only Access**: Recipients can view the page without authentication (like existing public URLs) but with tracked access for permission management
2. **Edit Access**: Recipients receive edit permissions to collaborate on the page content in real-time or asynchronously
3. **Clone Capability**: Collaborators with edit access can duplicate the page to their own vault, creating an independent copy

The feature maintains GDPR compliance with all data processing in UK/EU, includes email notifications via EU-based email service, and provides permission management UI for the page owner.

**Key Functionality:**
- Email-based sharing invitations with permission levels (read-only, edit)
- Share link generation with unique access tokens
- Permission management UI (view, revoke, modify access)
- Real-time or async collaborative editing for users with edit permissions
- Clone/duplicate feature for editors to copy pages to their vault
- Email notifications (invitation, permission changes, access revoked)
- GDPR-compliant invitation tracking

## Acceptance Criteria

### Sharing & Invitations
- [ ] User can share a published page via email with specified permission level
- [ ] System generates unique shareable links with embedded access tokens
- [ ] Email invitations sent via EU-based email service (e.g., SendGrid EU, AWS SES Europe)
- [ ] Invitation emails contain access link, permission level, and expiry date (optional)
- [ ] Recipients can access page via invitation link without creating an account (read-only)
- [ ] Recipients with edit permissions must authenticate to collaborate
- [ ] Share modal shows list of current collaborators with permission levels

### Permission Management
- [ ] Page owner can view all current shares and their permission levels
- [ ] Page owner can revoke access at any time
- [ ] Page owner can modify permissions (read → edit, edit → read)
- [ ] Revoked access prevents further page access via the invitation link
- [ ] System tracks when each share was created and last accessed
- [ ] Permission changes trigger email notifications to affected users

### Read-Only Sharing
- [ ] Read-only links allow viewing without authentication
- [ ] Read-only users cannot edit page content
- [ ] Read-only users cannot see unpublished changes
- [ ] Read-only access is tracked (view count per invitee)

### Edit Permissions
- [ ] Users with edit permissions can modify page content
- [ ] Changes are saved with author attribution
- [ ] Edit conflicts are handled gracefully (last-write-wins or operational transform)
- [ ] Page owner sees list of recent editors
- [ ] Editors can see who else has edit access

### Clone Capability
- [ ] Users with edit access see "Clone to My Vault" button
- [ ] Clone creates independent copy in user's vault
- [ ] Cloned page retains formatting and content
- [ ] Original page remains unchanged
- [ ] Clone is private by default (not published)
- [ ] User who cloned becomes owner of the new copy

### Security & Privacy (GDPR)
- [ ] All invitation data stored in UK/EU database
- [ ] Email service uses EU-based infrastructure
- [ ] Access tokens are cryptographically secure (256-bit)
- [ ] Tokens expire after configurable period (default: 90 days)
- [ ] Page owner can set expiry dates for shares
- [ ] No personally identifiable information stored beyond email addresses
- [ ] Users can request deletion of their invitation history

### User Experience
- [ ] Share modal is accessible from publish settings or page menu
- [ ] **Copyable weblink prominently displayed at top of share modal** (like Notion)
- [ ] Copy button/icon next to URL that copies link to clipboard
- [ ] Visual feedback (toast/checkmark) when URL is copied
- [ ] URL field shows full public URL in readable format
- [ ] Clear visual distinction between public URL and shared links
- [ ] Collaborators list shows avatars, names, permission levels, last access
- [ ] Toast notifications for successful shares, permission changes, revocations
- [ ] Email preview shown before sending invitation

## Tasks / Subtasks

### Task 1: Database Schema for Sharing & Permissions (3 hours)
**Estimated Time:** 3 hours

- [ ] Design database schema for sharing system
- [ ] Create `PageShare` model in Prisma schema:
  - `id` (cuid, primary key)
  - `pageId` (foreign key to PublishedPage)
  - `invitedEmail` (string, email of invitee)
  - `invitedBy` (foreign key to User)
  - `permission` (enum: 'read' | 'edit')
  - `accessToken` (unique string, 256-bit cryptographic token)
  - `expiresAt` (DateTime, optional expiry)
  - `createdAt` (DateTime)
  - `lastAccessedAt` (DateTime, nullable)
  - `accessCount` (Int, default 0)
  - `status` (enum: 'active' | 'revoked')
- [ ] Create `PageCollaborator` model for edit tracking:
  - `id` (cuid, primary key)
  - `pageId` (foreign key to PublishedPage)
  - `userId` (foreign key to User)
  - `shareId` (foreign key to PageShare, nullable)
  - `role` (enum: 'owner' | 'editor')
  - `lastEditedAt` (DateTime, nullable)
- [ ] Add indexes for performance:
  - `@@index([pageId])`
  - `@@index([accessToken])`
  - `@@index([invitedEmail])`
  - `@@index([status])`
- [ ] Generate migration: `npx prisma migrate dev --name add-page-sharing`
- [ ] Test migration locally
- [ ] Verify with `npx prisma migrate status`
- [ ] Commit both schema.prisma and migration files

### Task 2: Access Token Generation Utility (1.5 hours)
**Estimated Time:** 1.5 hours

- [ ] Create `/lib/access-tokens.ts` utility file
- [ ] Implement `generateAccessToken(): string`:
  - Use crypto.randomBytes(32) for 256-bit token
  - Encode as base64url (URL-safe)
  - Ensure uniqueness (check database)
  - Return token string
- [ ] Implement `verifyAccessToken(token: string): Promise<PageShare | null>`:
  - Query database for PageShare with token
  - Check if status is 'active'
  - Check if not expired (expiresAt > now)
  - Update lastAccessedAt and increment accessCount
  - Return PageShare object or null
- [ ] Implement `revokeAccessToken(shareId: string, userId: string): Promise<boolean>`:
  - Verify userId is page owner
  - Update PageShare status to 'revoked'
  - Return success boolean
- [ ] Add TypeScript interfaces:
  - `AccessTokenVerificationResult`
  - `AccessTokenPermission`
- [ ] Keep file under 150 lines
- [ ] Add JSDoc comments

### Task 3: Email Service Integration (4 hours)
**Estimated Time:** 4 hours

- [ ] Research EU-based email services:
  - SendGrid (Europe region)
  - AWS SES (eu-west-1, eu-central-1)
  - Postmark (EU servers)
  - Choose based on pricing and GDPR compliance documentation
- [ ] Create `/lib/email-service.ts` utility file
- [ ] Implement `sendShareInvitation()` function:
  - Parameters: `{ toEmail, fromUserName, pageTitle, accessLink, permission, expiryDate? }`
  - HTML email template with branding
  - Plain text fallback
  - Subject line: `${fromUserName} shared "${pageTitle}" with you`
  - Include access link with token
  - Specify permission level
  - Show expiry date if set
  - "Open Page" CTA button
- [ ] Implement `sendPermissionChanged()` function:
  - Notify when permissions updated (read ↔ edit)
- [ ] Implement `sendAccessRevoked()` function:
  - Notify when access removed
- [ ] Add environment variables:
  - `EMAIL_SERVICE_API_KEY`
  - `EMAIL_SERVICE_REGION=eu-west-1` (or equivalent)
  - `EMAIL_FROM_ADDRESS=noreply@edfolio.app`
  - `EMAIL_FROM_NAME=Edfolio`
- [ ] Create email templates in `/lib/email-templates/`:
  - `share-invitation.html`
  - `share-invitation.txt`
  - `permission-changed.html`
  - `access-revoked.html`
- [ ] Test email delivery in development (log to console)
- [ ] Document email service setup in .env.example
- [ ] Keep file under 200 lines

### Task 4: Share Management API Endpoints (4 hours)
**Estimated Time:** 4 hours

- [ ] Create `/app/api/notes/[noteId]/shares/route.ts`
- [ ] Implement GET endpoint (list shares):
  - Authenticate request
  - Verify note ownership
  - Query all PageShare records for noteId
  - Return shares with invitee info, permission, status, timestamps
  - Include access counts
- [ ] Implement POST endpoint (create share):
  - Authenticate request
  - Verify note ownership
  - Validate request body: `{ invitedEmail, permission, expiresAt? }`
  - Validate email format
  - Check if page is published (404 if not)
  - Generate unique access token
  - Create PageShare record
  - Send invitation email
  - Return share object with access link
- [ ] Create `/app/api/notes/[noteId]/shares/[shareId]/route.ts`
- [ ] Implement PATCH endpoint (update share):
  - Authenticate request
  - Verify note ownership
  - Validate request body: `{ permission?, status? }`
  - Update PageShare record
  - If permission changed: send permission-changed email
  - If status changed to 'revoked': send access-revoked email
  - Return updated share object
- [ ] Implement DELETE endpoint (revoke share):
  - Authenticate request
  - Verify note ownership
  - Update status to 'revoked'
  - Send access-revoked email
  - Return success response
- [ ] Add comprehensive error handling:
  - 401 Unauthorized
  - 403 Forbidden (not page owner)
  - 404 Not Found (note/share not found)
  - 400 Bad Request (validation errors)
  - 409 Conflict (duplicate email invitation)
  - 500 Internal Server Error
- [ ] Keep each file under 200 lines

### Task 5: Access Link Validation Middleware (2 hours)
**Estimated Time:** 2 hours

- [ ] Create `/app/api/public/[slug]/access/route.ts`
- [ ] Implement POST endpoint for access validation:
  - Accept: `{ accessToken: string }`
  - Query PageShare by accessToken
  - Verify token is active and not expired
  - Verify page is published
  - Update lastAccessedAt and accessCount
  - Return: `{ valid: boolean, permission: 'read' | 'edit', pageData }`
- [ ] Update `/app/public/[slug]/page.tsx`:
  - Check URL for `?token=` query parameter
  - If token present, validate via API endpoint
  - If valid read token: render page normally
  - If valid edit token: show edit mode UI or redirect to editor
  - If invalid/expired token: show error message
  - Store validated token in session storage (for duration of session)
- [ ] Implement token-based access control:
  - Read-only: show page, no edit buttons
  - Edit: show full editor interface
  - No token or invalid: show public view only
- [ ] Keep file under 150 lines

### Task 6: Share Management UI Component (4 hours)
**Estimated Time:** 4 hours

- [ ] Create `/components/publish/ShareManagementModal.tsx`
- [ ] Define ShareManagementModalProps interface:
  - `isOpen: boolean`
  - `onClose: () => void`
  - `noteId: string`
  - `noteTitle: string`
- [ ] Implement modal structure:
  - **Header Section:**
    - Title: "Share & Collaborate"
    - Close button
  - **New Share Section:**
    - Email input field with validation
    - Permission dropdown (Read-only / Can edit)
    - Optional expiry date picker
    - "Send Invitation" button
    - Preview of invitation email (expandable)
  - **Current Shares Section:**
    - List of active shares
    - Each share shows:
      - Invitee email/name
      - Permission badge (Read / Edit)
      - Last accessed timestamp
      - Access count
      - Actions: Change permission, Revoke access
    - Empty state: "No shares yet. Invite collaborators above."
  - **Public Link Section:**
    - Distinguished from private shares
    - Public URL with copy button
    - Note: "Anyone with this link can view your page"
- [ ] Implement share creation:
  - Validate email format
  - Call POST /api/notes/[noteId]/shares
  - Show success toast: "Invitation sent to {email}"
  - Refresh shares list
  - Clear form
- [ ] Implement permission change:
  - Dropdown to change permission
  - Confirm dialog: "Change {email}'s permission to {newPermission}?"
  - Call PATCH endpoint
  - Show success toast
  - Update list in real-time
- [ ] Implement access revocation:
  - Confirm dialog: "Revoke {email}'s access? They will no longer be able to view or edit this page."
  - Call DELETE endpoint
  - Show success toast: "Access revoked for {email}"
  - Remove from list
- [ ] Add loading states for all async operations
- [ ] Use CSS variables for all styling
- [ ] Keep component under 250 lines

### Task 7: Invitation Email Templates (2 hours)
**Estimated Time:** 2 hours

- [ ] Create `/lib/email-templates/share-invitation.html`
- [ ] Design HTML email template:
  - Edfolio branding (logo, colors)
  - Personalized greeting: "Hi there,"
  - Message: "{Sender} has shared "{PageTitle}" with you"
  - Permission level clearly stated
  - Prominent "Open Page" CTA button
  - Access link (with token)
  - Expiry notice if applicable
  - Footer: "Powered by Edfolio" with link
  - Unsubscribe link (GDPR requirement)
- [ ] Create plain text version: `share-invitation.txt`
- [ ] Create `permission-changed.html`:
  - Subject: "Your permissions changed for "{PageTitle}""
  - Content: Permission updated from {old} to {new}
- [ ] Create `access-revoked.html`:
  - Subject: "Access removed for "{PageTitle}""
  - Content: Owner has revoked your access
- [ ] Test email rendering in Email on Acid or Litmus
- [ ] Ensure mobile responsive design
- [ ] Verify all links work correctly
- [ ] Keep templates clean and accessible

### Task 8: Collaborator Edit Mode UI (5 hours)
**Estimated Time:** 5 hours

- [ ] Modify `/components/editor/TipTapEditor.tsx` to support collaboration mode
- [ ] Add `collaborationMode` prop:
  - `{ enabled: boolean, shareToken: string, permission: 'read' | 'edit' }`
- [ ] Implement edit mode UI changes:
  - Show banner: "You're editing as a collaborator"
  - Display list of other active editors (if real-time)
  - Add "Stop Editing" button (clears session, returns to read-only)
  - Disable editing if permission is 'read'
- [ ] Implement save mechanism for collaborators:
  - Use same auto-save as owner
  - Send PATCH request to `/api/notes/[noteId]/collaborate`
  - Include shareToken in request header
  - Save author attribution (collaborator email/name)
- [ ] Create `/app/api/notes/[noteId]/collaborate/route.ts`:
  - PATCH endpoint for collaborative editing
  - Verify shareToken validity
  - Verify permission is 'edit'
  - Update note content
  - Record edit in PageCollaborator table
  - Return success
- [ ] Handle edit conflicts:
  - Use last-write-wins strategy (simple)
  - OR implement basic operational transform (complex)
  - Show warning if content changed since last load
  - Option to "Reload" or "Overwrite"
- [ ] Add change history tracking:
  - Record who made changes and when
  - Display recent editors in sidebar
- [ ] Keep editor changes under 100 additional lines

### Task 9: Clone Feature Implementation (3 hours)
**Estimated Time:** 3 hours

- [ ] Create `/app/api/notes/[noteId]/clone/route.ts`
- [ ] Implement POST endpoint:
  - Authenticate request
  - Verify user has edit permission (via shareToken or ownership)
  - Query source note with all content
  - Create new note in user's default folio:
    - Title: "{OriginalTitle} (Copy)"
    - Content: Copy of original content
    - ownerId: Current user ID
    - isPublished: false (private by default)
  - Return new note ID and redirect URL
- [ ] Add "Clone to My Vault" button:
  - Create `/components/publish/CloneButton.tsx`
  - Show button on public page if user has edit permission
  - Display clone confirmation dialog:
    - "Clone this page to your vault?"
    - "This will create a private copy you can edit independently."
    - "Original page will not be affected."
  - On confirm: Call clone API endpoint
  - On success: Show toast: "Page cloned successfully"
  - Offer action: "Open in Editor" (redirect to new note)
- [ ] Integrate CloneButton into public page layout:
  - Show in header if user authenticated and has edit permission
  - Hide if user is page owner (no need to clone own page)
- [ ] Keep clone endpoint under 150 lines
- [ ] Keep CloneButton component under 100 lines

### Task 10: Permission Badges & Visual Indicators (2 hours)
**Estimated Time:** 2 hours

- [ ] Create `/components/publish/PermissionBadge.tsx`
- [ ] Implement badge component:
  - Props: `{ permission: 'read' | 'edit', size?: 'sm' | 'md' | 'lg' }`
  - Styles:
    - Read-only: Gray background, Eye icon
    - Can edit: Blue background, Edit icon
  - Use CSS variables
- [ ] Create `/components/publish/CollaboratorAvatar.tsx`:
  - Display user avatar or initials
  - Show permission badge overlay
  - Tooltip on hover: Name, email, permission, last accessed
- [ ] Update ShareManagementModal to use PermissionBadge
- [ ] Add permission indicator to public page:
  - If viewing via shared link, show banner: "You have {permission} access"
- [ ] Keep components under 100 lines each

### Task 11: Access Analytics Integration (2 hours)
**Estimated Time:** 2 hours

- [ ] Extend `/components/publish/PublishAnalytics.tsx` (from Story 3.3)
- [ ] Add "Shares & Collaborators" section:
  - Total shares: {count}
  - Active shares: {count}
  - Total editors: {count}
  - Recent edits: {count in last 7 days}
- [ ] Create `/app/api/notes/[noteId]/shares/analytics/route.ts`:
  - GET endpoint
  - Authenticate request
  - Verify note ownership
  - Query aggregated share statistics
  - Query recent edit activity
  - Return analytics data
- [ ] Display share analytics in PublishSettingsModal:
  - Show below view analytics
  - Link to "Manage Shares" opens ShareManagementModal
- [ ] Keep changes under 100 additional lines

### Task 12: Expiry & Cleanup Background Job (3 hours)
**Estimated Time:** 3 hours

- [ ] Create `/lib/background-jobs/share-expiry.ts`
- [ ] Implement expiry check function:
  - Query all PageShare records where expiresAt < now AND status = 'active'
  - Update status to 'revoked'
  - Send expiry notification emails
  - Log expired shares
- [ ] Implement using Next.js API route cron job:
  - Create `/app/api/cron/expire-shares/route.ts`
  - Implement GET endpoint (triggered by cron)
  - Verify cron secret header (security)
  - Call expiry check function
  - Return summary: {expired: count}
- [ ] Configure Vercel Cron (or Railway equivalent):
  - Schedule: Daily at 00:00 UTC
  - Endpoint: `/api/cron/expire-shares`
  - Secret header: `x-cron-secret`
- [ ] Add environment variable:
  - `CRON_SECRET` (random 32-char string)
- [ ] Test expiry logic manually:
  - Create share with expiresAt in past
  - Run expiry function
  - Verify status updated and email sent
- [ ] Document cron setup in deployment guide
- [ ] Keep files under 150 lines each

### Task 13: Type Definitions for Sharing System (1 hour)
**Estimated Time:** 1 hour

- [ ] Open `/types/index.ts`
- [ ] Add sharing-related interfaces:
  ```typescript
  /**
   * Permission level for page shares
   */
  export type SharePermission = 'read' | 'edit';

  /**
   * Status of a page share
   */
  export type ShareStatus = 'active' | 'revoked';

  /**
   * Page share record
   */
  export interface PageShare {
    id: string;
    pageId: string;
    invitedEmail: string;
    invitedBy: string;
    permission: SharePermission;
    accessToken: string;
    expiresAt: Date | null;
    createdAt: Date;
    lastAccessedAt: Date | null;
    accessCount: number;
    status: ShareStatus;
  }

  /**
   * Request body for creating a share
   */
  export interface CreateShareRequest {
    invitedEmail: string;
    permission: SharePermission;
    expiresAt?: Date;
  }

  /**
   * Request body for updating a share
   */
  export interface UpdateShareRequest {
    permission?: SharePermission;
    status?: ShareStatus;
  }

  /**
   * Props for ShareManagementModal component
   */
  export interface ShareManagementModalProps {
    isOpen: boolean;
    onClose: () => void;
    noteId: string;
    noteTitle: string;
  }

  /**
   * Props for PermissionBadge component
   */
  export interface PermissionBadgeProps {
    permission: SharePermission;
    size?: 'sm' | 'md' | 'lg';
  }

  /**
   * Props for CloneButton component
   */
  export interface CloneButtonProps {
    noteId: string;
    noteTitle: string;
    shareToken?: string;
  }
  ```
- [ ] Export all new types
- [ ] Keep file under 300 lines

### Task 14: Security Audit & GDPR Compliance (2.5 hours)
**Estimated Time:** 2.5 hours

- [ ] Review all API endpoints for security:
  - [ ] Verify authentication on all protected routes
  - [ ] Verify ownership checks before allowing modifications
  - [ ] Ensure access tokens are cryptographically secure
  - [ ] Check for SQL injection vulnerabilities (Prisma prevents most)
  - [ ] Validate all user inputs
- [ ] GDPR compliance audit:
  - [ ] Verify all data stored in EU database
  - [ ] Verify email service uses EU infrastructure
  - [ ] Check that invitation emails include unsubscribe link
  - [ ] Ensure users can request deletion of share history
  - [ ] Verify no unnecessary PII collected
  - [ ] Review data retention policies (expired shares)
- [ ] Rate limiting:
  - [ ] Add rate limits to share creation (max 10 per hour per user)
  - [ ] Add rate limits to access token validation
  - [ ] Implement using Redis or in-memory cache
- [ ] Create `/lib/rate-limiting.ts` utility:
  - Implement `checkRateLimit(userId: string, action: string, limit: number): Promise<boolean>`
  - Track actions in memory cache
  - Return true if under limit, false if over
- [ ] Document security measures in Dev Notes
- [ ] Document GDPR compliance in Dev Notes

### Task 15: Integration Testing (5 hours)
**Estimated Time:** 5 hours

- [ ] **Share Creation Flow:**
  - [ ] Create share with read-only permission
  - [ ] Verify invitation email sent
  - [ ] Click invitation link → verify page accessible
  - [ ] Verify cannot edit (read-only)
  - [ ] Create share with edit permission
  - [ ] Verify invitation email sent
  - [ ] Authenticate and click link → verify edit mode enabled
- [ ] **Permission Management:**
  - [ ] Change read → edit → verify email notification
  - [ ] Change edit → read → verify edit mode disabled
  - [ ] Revoke access → verify email notification
  - [ ] Attempt to access with revoked token → verify 403 error
- [ ] **Collaborative Editing:**
  - [ ] Open page with edit permission
  - [ ] Make edits → verify saved
  - [ ] Verify author attribution recorded
  - [ ] Simulate conflict → verify resolution works
- [ ] **Clone Feature:**
  - [ ] Access page with edit permission
  - [ ] Click "Clone to My Vault"
  - [ ] Verify new note created in user's vault
  - [ ] Verify content copied correctly
  - [ ] Edit clone → verify original unchanged
- [ ] **Access Token Security:**
  - [ ] Generate token → verify uniqueness
  - [ ] Attempt to guess token → verify fails
  - [ ] Use expired token → verify access denied
  - [ ] Use revoked token → verify access denied
- [ ] **Email Delivery:**
  - [ ] Send invitation → verify email delivered
  - [ ] Check spam folder
  - [ ] Verify links work
  - [ ] Verify unsubscribe link works
- [ ] **Analytics:**
  - [ ] View share analytics → verify counts correct
  - [ ] Access shared page → verify accessCount increments
  - [ ] Verify lastAccessedAt updates
- [ ] **GDPR Compliance:**
  - [ ] Verify all data in EU database
  - [ ] Verify email service region
  - [ ] Test unsubscribe functionality
- [ ] **Error Handling:**
  - [ ] Invalid email format → 400 error
  - [ ] Duplicate email invitation → 409 error
  - [ ] Non-owner trying to share → 403 error
  - [ ] Invalid token → 404 error
  - [ ] Expired token → 403 error
- [ ] **Build Validation:**
  - [ ] Run `pnpm run build` → zero errors
  - [ ] Verify no TypeScript errors
  - [ ] Verify no ESLint errors

## Dev Notes

### Architecture Overview

This story implements a comprehensive sharing and collaboration system on top of the existing public publishing feature (Story 3.1). The architecture follows these principles:

1. **Token-Based Access Control**: Each share generates a unique, cryptographically secure access token embedded in invitation links
2. **Permission Layers**: Three levels of access (public view, read-only share, edit share)
3. **Email-Driven Workflow**: All invitations and notifications sent via EU-based email service
4. **GDPR-First Design**: All data processing in UK/EU, minimal PII collection, user control over data

**Access Hierarchy:**
- **Public URL** (Story 3.1): Anyone can view, no tracking
- **Read-Only Share** (This story): Specific email invited, access tracked
- **Edit Share** (This story): Authenticated users can collaborate
- **Owner** (Existing): Full control, can manage all shares

**User Flows:**

1. **Sharing Flow:**
   - Owner clicks "Share" in publish settings
   - Opens ShareManagementModal
   - Enters invitee email, selects permission
   - System generates access token
   - Invitation email sent with access link
   - Invitee receives email, clicks link
   - If read-only: Views page immediately
   - If edit: Must authenticate, then gains edit access

2. **Collaborative Editing Flow:**
   - User with edit permission opens shared link
   - Authenticates (if not already)
   - Editor loads in collaboration mode
   - Banner shows "Editing as collaborator"
   - Changes auto-save with author attribution
   - Other editors can see recent activity
   - Edit conflicts resolved (last-write-wins)

3. **Clone Flow:**
   - User with edit permission views shared page
   - Clicks "Clone to My Vault" button
   - Confirmation dialog appears
   - On confirm, API creates new note in user's vault
   - User redirected to new note in editor
   - Original page unchanged

### Database Schema Changes

**CRITICAL:** Follow `/docs/MIGRATION-WORKFLOW.md` exactly. Never modify migration files after creation.

**New Models:**

```prisma
// Add to schema.prisma

enum SharePermission {
  read
  edit
}

enum ShareStatus {
  active
  revoked
}

model PageShare {
  id              String          @id @default(cuid())
  pageId          String
  page            PublishedPage   @relation(fields: [pageId], references: [id], onDelete: Cascade)

  // Invitation details
  invitedEmail    String
  invitedBy       String
  inviter         User            @relation("Inviter", fields: [invitedBy], references: [id])
  permission      SharePermission @default(read)

  // Access control
  accessToken     String          @unique @db.Text
  expiresAt       DateTime?
  status          ShareStatus     @default(active)

  // Analytics
  createdAt       DateTime        @default(now())
  lastAccessedAt  DateTime?
  accessCount     Int             @default(0)

  @@index([pageId])
  @@index([accessToken])
  @@index([invitedEmail])
  @@index([status])
  @@index([expiresAt])
}

model PageCollaborator {
  id            String        @id @default(cuid())
  pageId        String
  page          PublishedPage @relation(fields: [pageId], references: [id], onDelete: Cascade)
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  shareId       String?
  share         PageShare?    @relation(fields: [shareId], references: [id])
  role          String        // 'owner' | 'editor'
  lastEditedAt  DateTime?

  @@unique([pageId, userId])
  @@index([pageId])
  @@index([userId])
}

// Update existing models
model PublishedPage {
  // ... existing fields
  shares         PageShare[]
  collaborators  PageCollaborator[]
}

model User {
  // ... existing fields
  invitedShares  PageShare[]     @relation("Inviter")
  collaborations PageCollaborator[]
}
```

**Migration Command:**
```bash
npx prisma migrate dev --name add-page-sharing-and-collaboration
```

### Access Token Security

**File Path:** `/Users/darrencoxon/Dropbox/Coxon team folder/coding_projects_25/edfolio/lib/access-tokens.ts`

**Token Generation:**
- Use Node.js `crypto.randomBytes(32)` for cryptographically secure 256-bit tokens
- Encode as base64url (URL-safe, no padding)
- Example token: `a3f8g2k9s1m4n7p0q5r8t2u6v9w3x7y1z4b6c9d2e5f8h1j4k7m0n3p6r9s2t5`
- Check uniqueness in database before returning

**Token Format:**
```typescript
{
  accessToken: string, // 43-character base64url string
  pageId: string,
  permission: 'read' | 'edit',
  expiresAt: Date | null,
  status: 'active' | 'revoked'
}
```

**Verification Process:**
1. Query PageShare by accessToken (indexed, fast lookup)
2. Check status === 'active'
3. Check expiresAt === null OR expiresAt > now
4. Update lastAccessedAt to current timestamp
5. Increment accessCount by 1
6. Return PageShare object with permission level

**Security Measures:**
- Tokens are 256-bit (2^256 possibilities, practically unguessable)
- Tokens stored as-is in database (not hashed, they're not passwords)
- Each token is unique (enforced by database unique constraint)
- Expired tokens automatically invalid (checked on every access)
- Revoked tokens immediately invalid (status check)
- Rate limiting prevents brute-force token guessing

### Email Service Integration

**Recommended Service:** **AWS SES (eu-west-1 region)**

**Why AWS SES:**
- EU infrastructure (Frankfurt, Ireland data centers)
- Cost-effective (€0.10 per 1000 emails)
- GDPR-compliant
- Reliable delivery rates
- Supports HTML and plain text
- Easy integration with Node.js SDK

**Alternative:** **SendGrid (Europe region)**
- Explicit EU data center option
- Free tier: 100 emails/day
- Good documentation
- GDPR-compliant

**Environment Variables:**
```bash
# Email Service Configuration
EMAIL_SERVICE=aws-ses # or 'sendgrid'
EMAIL_SERVICE_API_KEY=your-api-key-here
EMAIL_SERVICE_REGION=eu-west-1
EMAIL_FROM_ADDRESS=noreply@edfolio.app
EMAIL_FROM_NAME=Edfolio
EMAIL_REPLY_TO=support@edfolio.app

# For SendGrid (alternative)
SENDGRID_API_KEY=your-sendgrid-api-key
SENDGRID_EU_REGION=true
```

**Email Template Structure:**

**Invitation Email (share-invitation.html):**
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Page Shared with You</title>
  <style>
    /* Mobile-friendly, GDPR-compliant email styles */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      line-height: 1.6;
      color: #1A1A1A;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    .header {
      text-align: center;
      padding: 20px 0;
      border-bottom: 2px solid #3B82F6;
    }
    .content {
      padding: 30px 0;
    }
    .cta-button {
      display: inline-block;
      background-color: #3B82F6;
      color: white;
      padding: 12px 30px;
      text-decoration: none;
      border-radius: 6px;
      font-weight: 600;
      margin: 20px 0;
    }
    .footer {
      font-size: 12px;
      color: #6B7280;
      text-align: center;
      padding: 20px 0;
      border-top: 1px solid #E5E7EB;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1 style="color: #3B82F6; margin: 0;">Edfolio</h1>
  </div>

  <div class="content">
    <p>Hi there,</p>

    <p><strong>{{senderName}}</strong> has shared a page with you:</p>

    <h2 style="color: #1A1A1A;">{{pageTitle}}</h2>

    <p>You have <strong>{{permission}}</strong> access to this page.</p>

    {{#if expiryDate}}
    <p style="color: #6B7280; font-size: 14px;">
      This invitation expires on {{expiryDate}}.
    </p>
    {{/if}}

    <div style="text-align: center;">
      <a href="{{accessLink}}" class="cta-button">Open Page</a>
    </div>

    <p style="color: #6B7280; font-size: 14px;">
      Or copy and paste this link into your browser:<br>
      <a href="{{accessLink}}">{{accessLink}}</a>
    </p>
  </div>

  <div class="footer">
    <p>
      Powered by <a href="https://edfolio.app">Edfolio</a><br>
      <a href="{{unsubscribeLink}}">Unsubscribe</a>
    </p>
  </div>
</body>
</html>
```

**Plain Text Version (share-invitation.txt):**
```
Hi there,

{{senderName}} has shared a page with you: "{{pageTitle}}"

You have {{permission}} access to this page.

{{#if expiryDate}}
This invitation expires on {{expiryDate}}.
{{/if}}

Open the page here:
{{accessLink}}

---
Powered by Edfolio
Unsubscribe: {{unsubscribeLink}}
```

### API Endpoint Specifications

**1. List Shares (GET /api/notes/[noteId]/shares)**

**Request:**
- Headers: `Authorization: Bearer {token}`
- Params: `noteId` (string)

**Response (200 OK):**
```json
{
  "data": [
    {
      "id": "share_abc123",
      "invitedEmail": "colleague@example.com",
      "permission": "edit",
      "status": "active",
      "createdAt": "2025-10-22T10:00:00Z",
      "lastAccessedAt": "2025-10-23T14:30:00Z",
      "accessCount": 5,
      "expiresAt": "2026-01-22T10:00:00Z"
    }
  ]
}
```

**2. Create Share (POST /api/notes/[noteId]/shares)**

**Request:**
```json
{
  "invitedEmail": "colleague@example.com",
  "permission": "edit",
  "expiresAt": "2026-01-22T10:00:00Z" // Optional
}
```

**Response (201 Created):**
```json
{
  "data": {
    "id": "share_abc123",
    "invitedEmail": "colleague@example.com",
    "permission": "edit",
    "accessLink": "https://edfolio.app/public/my-page?token=a3f8g2k9...",
    "expiresAt": "2026-01-22T10:00:00Z"
  }
}
```

**3. Update Share (PATCH /api/notes/[noteId]/shares/[shareId])**

**Request:**
```json
{
  "permission": "read" // Or "status": "revoked"
}
```

**Response (200 OK):**
```json
{
  "data": {
    "id": "share_abc123",
    "permission": "read",
    "status": "active"
  }
}
```

**4. Revoke Share (DELETE /api/notes/[noteId]/shares/[shareId])**

**Response (200 OK):**
```json
{
  "success": true,
  "message": "Access revoked successfully"
}
```

**5. Validate Access Token (POST /api/public/[slug]/access)**

**Request:**
```json
{
  "accessToken": "a3f8g2k9..."
}
```

**Response (200 OK):**
```json
{
  "valid": true,
  "permission": "edit",
  "pageData": {
    "id": "page_123",
    "title": "My Page",
    "slug": "my-page",
    "content": "..."
  }
}
```

**Error Response (403 Forbidden):**
```json
{
  "valid": false,
  "error": "Token expired"
}
```

**6. Clone Page (POST /api/notes/[noteId]/clone)**

**Request:**
- Headers: `Authorization: Bearer {token}` or `X-Access-Token: {shareToken}`

**Response (201 Created):**
```json
{
  "data": {
    "noteId": "note_xyz789",
    "title": "My Page (Copy)",
    "redirectUrl": "/editor/note_xyz789"
  }
}
```

### ShareManagementModal Component

**File Path:** `/Users/darrencoxon/Dropbox/Coxon team folder/coding_projects_25/edfolio/components/publish/ShareManagementModal.tsx`

**Component Structure:**

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Label } from '@/components/ui/label';
import { toast } from 'sonner';
import { Mail, Eye, Edit, Trash2, MoreVertical, Link } from 'lucide-react';
import { ShareManagementModalProps, PageShare, SharePermission } from '@/types';

export function ShareManagementModal({
  isOpen,
  onClose,
  noteId,
  noteTitle,
}: ShareManagementModalProps) {
  const [shares, setShares] = useState<PageShare[]>([]);
  const [loading, setLoading] = useState(false);
  const [inviteEmail, setInviteEmail] = useState('');
  const [invitePermission, setInvitePermission] = useState<SharePermission>('read');
  const [expiryDate, setExpiryDate] = useState<string>('');

  // Fetch existing shares
  useEffect(() => {
    if (isOpen) {
      fetchShares();
    }
  }, [isOpen, noteId]);

  const fetchShares = async () => {
    try {
      const response = await fetch(`/api/notes/${noteId}/shares`);
      const result = await response.json();
      setShares(result.data || []);
    } catch (error) {
      console.error('Failed to fetch shares:', error);
    }
  };

  const handleCreateShare = async () => {
    if (!inviteEmail || !validateEmail(inviteEmail)) {
      toast.error('Please enter a valid email address');
      return;
    }

    setLoading(true);
    try {
      const response = await fetch(`/api/notes/${noteId}/shares`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          invitedEmail: inviteEmail,
          permission: invitePermission,
          expiresAt: expiryDate ? new Date(expiryDate).toISOString() : undefined,
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to create share');
      }

      toast.success(`Invitation sent to ${inviteEmail}`);
      setInviteEmail('');
      setInvitePermission('read');
      setExpiryDate('');
      fetchShares();
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to send invitation');
    } finally {
      setLoading(false);
    }
  };

  const handleRevokeShare = async (shareId: string, email: string) => {
    if (!confirm(`Revoke ${email}'s access to this page?`)) {
      return;
    }

    try {
      await fetch(`/api/notes/${noteId}/shares/${shareId}`, {
        method: 'DELETE',
      });
      toast.success(`Access revoked for ${email}`);
      fetchShares();
    } catch (error) {
      toast.error('Failed to revoke access');
    }
  };

  const handleChangePermission = async (shareId: string, newPermission: SharePermission) => {
    try {
      await fetch(`/api/notes/${noteId}/shares/${shareId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ permission: newPermission }),
      });
      toast.success('Permission updated');
      fetchShares();
    } catch (error) {
      toast.error('Failed to update permission');
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Share & Collaborate</DialogTitle>
        </DialogHeader>

        {/* Copyable Public URL Section (like Notion) */}
        <div className="bg-muted/30 p-(--spacing-md) rounded-md border border-border">
          <Label className="text-xs text-muted mb-(--spacing-xs)">Public URL</Label>
          <div className="flex items-center gap-(--spacing-sm) mt-(--spacing-xs)">
            <Input
              readOnly
              value={`${window.location.origin}/public/${noteId}`}
              className="bg-background text-sm font-mono"
            />
            <Button
              variant="ghost"
              size="sm"
              onClick={async () => {
                await navigator.clipboard.writeText(`${window.location.origin}/public/${noteId}`);
                toast.success('Link copied to clipboard');
              }}
            >
              <Link className="h-4 w-4" />
            </Button>
          </div>
        </div>

        {/* New Invitation Section */}
        <div className="space-y-(--spacing-md) border-b border-border pb-(--spacing-lg)">
          <h3 className="text-sm font-medium text-foreground">Invite Collaborators</h3>

          <div className="space-y-(--spacing-sm)">
            <Label htmlFor="inviteEmail">Email Address</Label>
            <Input
              id="inviteEmail"
              type="email"
              value={inviteEmail}
              onChange={(e) => setInviteEmail(e.target.value)}
              placeholder="colleague@example.com"
            />
          </div>

          <div className="grid grid-cols-2 gap-(--spacing-sm)">
            <div>
              <Label htmlFor="permission">Permission</Label>
              <Select value={invitePermission} onValueChange={(v) => setInvitePermission(v as SharePermission)}>
                <SelectTrigger id="permission">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="read">
                    <div className="flex items-center gap-2">
                      <Eye className="h-4 w-4" />
                      <span>Can view</span>
                    </div>
                  </SelectItem>
                  <SelectItem value="edit">
                    <div className="flex items-center gap-2">
                      <Edit className="h-4 w-4" />
                      <span>Can edit</span>
                    </div>
                  </SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div>
              <Label htmlFor="expiryDate">Expiry Date (Optional)</Label>
              <Input
                id="expiryDate"
                type="date"
                value={expiryDate}
                onChange={(e) => setExpiryDate(e.target.value)}
              />
            </div>
          </div>

          <Button onClick={handleCreateShare} disabled={loading} className="w-full">
            <Mail className="h-4 w-4 mr-2" />
            {loading ? 'Sending...' : 'Send Invitation'}
          </Button>
        </div>

        {/* Current Shares List */}
        <div className="space-y-(--spacing-md)">
          <h3 className="text-sm font-medium text-foreground">
            Current Shares ({shares.length})
          </h3>

          {shares.length === 0 ? (
            <div className="text-center py-(--spacing-xl) text-muted">
              <p className="text-sm">No shares yet</p>
              <p className="text-xs mt-1">Invite collaborators above to share this page</p>
            </div>
          ) : (
            <div className="space-y-(--spacing-sm)">
              {shares.map((share) => (
                <div
                  key={share.id}
                  className="flex items-center justify-between p-(--spacing-sm) border border-border rounded-lg"
                >
                  <div className="flex-1">
                    <p className="font-medium text-sm text-foreground">{share.invitedEmail}</p>
                    <div className="flex items-center gap-(--spacing-sm) mt-1">
                      <PermissionBadge permission={share.permission} size="sm" />
                      {share.lastAccessedAt && (
                        <span className="text-xs text-muted">
                          Last accessed {formatRelativeTime(share.lastAccessedAt)}
                        </span>
                      )}
                      <span className="text-xs text-muted">
                        {share.accessCount} {share.accessCount === 1 ? 'view' : 'views'}
                      </span>
                    </div>
                  </div>

                  <div className="flex items-center gap-(--spacing-xs)">
                    <Select
                      value={share.permission}
                      onValueChange={(v) => handleChangePermission(share.id, v as SharePermission)}
                    >
                      <SelectTrigger className="w-[120px]">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="read">Can view</SelectItem>
                        <SelectItem value="edit">Can edit</SelectItem>
                      </SelectContent>
                    </Select>

                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleRevokeShare(share.id, share.invitedEmail)}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}

// Helper functions
function validateEmail(email: string): boolean {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

function formatRelativeTime(date: Date): string {
  const now = Date.now();
  const diff = now - new Date(date).getTime();
  const minutes = Math.floor(diff / 60000);

  if (minutes < 1) return 'just now';
  if (minutes < 60) return `${minutes}m ago`;
  if (minutes < 1440) return `${Math.floor(minutes / 60)}h ago`;
  return `${Math.floor(minutes / 1440)}d ago`;
}
```

**Component keeps under 250 lines by splitting helper functions and sub-components.**

### Collaborative Editing Strategy

**Approach:** **Last-Write-Wins with Conflict Warning**

This is the simplest approach for MVP. More sophisticated operational transform (OT) or CRDTs can be added later.

**How It Works:**
1. User A and User B both open page with edit permission
2. Both see latest content from database
3. User A makes edit, auto-saves after 500ms debounce
4. User A's edit saved to database with timestamp
5. User B makes edit 2 seconds later, auto-saves
6. User B's edit overwrites User A's (last write wins)
7. Next time User A reloads, they see User B's version

**Conflict Detection:**
- When saving, check `updatedAt` timestamp in database
- If database version is newer than user's loaded version, show warning:
  - "This page was edited by someone else while you were working"
  - Options: "Reload and lose my changes" OR "Save anyway (overwrite)"

**Future Enhancement:** Implement operational transform for true real-time collaboration (like Google Docs). This is complex and out of scope for MVP.

### Clone Feature Implementation

**File Path:** `/Users/darrencoxon/Dropbox/Coxon team folder/coding_projects_25/edfolio/app/api/notes/[noteId]/clone/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { verifyAccessToken } from '@/lib/access-tokens';

export async function POST(
  request: NextRequest,
  { params }: { params: { noteId: string } }
) {
  try {
    const session = await auth();

    // Check if user is authenticated
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const noteId = params.noteId;

    // Check if user has permission to clone (either owner or edit share)
    let hasPermission = false;

    // Check ownership
    const note = await prisma.note.findUnique({
      where: { id: noteId },
      include: {
        folio: { select: { ownerId: true } },
        published: true,
      },
    });

    if (!note) {
      return NextResponse.json({ error: 'Note not found' }, { status: 404 });
    }

    if (note.folio.ownerId === session.user.id) {
      // Owner can clone (though this is unusual)
      hasPermission = true;
    } else {
      // Check if user has edit share permission
      const { accessToken } = await request.json();
      if (accessToken) {
        const share = await verifyAccessToken(accessToken);
        if (share && share.permission === 'edit' && share.pageId === note.published?.id) {
          hasPermission = true;
        }
      }
    }

    if (!hasPermission) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    // Get user's default folio
    const userFolio = await prisma.folio.findFirst({
      where: { ownerId: session.user.id },
      orderBy: { createdAt: 'asc' },
    });

    if (!userFolio) {
      return NextResponse.json({ error: 'No folio found' }, { status: 404 });
    }

    // Clone the note
    const clonedNote = await prisma.note.create({
      data: {
        title: `${note.title} (Copy)`,
        content: note.content,
        folioId: userFolio.id,
        // Not published by default
      },
    });

    return NextResponse.json({
      data: {
        noteId: clonedNote.id,
        title: clonedNote.title,
        redirectUrl: `/editor/${clonedNote.id}`,
      },
    }, { status: 201 });

  } catch (error) {
    console.error('Clone error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### GDPR Compliance Checklist

**Data Residency:**
- [x] All database data stored in Railway Europe region
- [x] Email service uses EU infrastructure (AWS SES eu-west-1)
- [x] No data processing outside UK/EU

**Data Minimization:**
- [x] Only collect necessary data: email addresses, access tokens, timestamps
- [x] No tracking cookies on public pages
- [x] No IP address storage (used only for rate limiting in memory)
- [x] No third-party analytics scripts

**User Rights:**
- [x] Users can revoke access at any time (instant effect)
- [x] Users can request deletion of share history
- [x] Email unsubscribe link in all notifications
- [x] Clear privacy policy and terms linked in emails

**Security:**
- [x] Access tokens are cryptographically secure
- [x] All API endpoints require authentication for sensitive operations
- [x] Input validation on all user-provided data
- [x] Rate limiting to prevent abuse

**Consent:**
- [x] Invitees implicitly consent by clicking invitation link
- [x] Email notifications are functional (not marketing)
- [x] Opt-out mechanism provided (unsubscribe)

### Testing Strategy

**Unit Tests:**
- Access token generation uniqueness
- Token expiry logic
- Permission validation
- Email template rendering

**Integration Tests:**
- Complete share creation flow
- Permission change flow
- Access revocation flow
- Clone flow
- Email delivery

**Security Tests:**
- Token guessing resistance
- Access control bypass attempts
- SQL injection attempts (Prisma prevents)
- XSS in user inputs

**Performance Tests:**
- Share creation time < 1 second
- Access token validation < 100ms
- Email delivery < 5 seconds
- Page load with shared access < 1 second

**GDPR Tests:**
- Verify EU data storage
- Verify email service region
- Test unsubscribe functionality
- Verify data deletion

### Known Limitations & Future Enhancements

**Current Implementation (MVP):**
- Last-write-wins collaboration (no operational transform)
- No real-time presence indicators
- No comment/annotation system
- Manual expiry check (daily cron job)
- Single owner per page

**Future Enhancements (Out of Scope):**
- **Real-Time Collaboration:**
  - WebSocket-based presence
  - Operational transform or CRDTs
  - Live cursor positions
  - Conflict-free editing
- **Advanced Features:**
  - Comments and annotations
  - Version history with rollback
  - Granular permission (comment-only)
  - Team/organization sharing
  - SSO integration
- **Analytics:**
  - Detailed activity logs
  - Engagement metrics
  - Most active collaborators
- **Export:**
  - Export share activity to CSV
  - Audit trail for compliance

### Timeline Estimate

**Total estimated time: 44 hours**

Breakdown:
- Database schema: 3 hours
- Access tokens utility: 1.5 hours
- Email service integration: 4 hours
- Share management API: 4 hours
- Access link validation: 2 hours
- ShareManagementModal UI: 4 hours
- Email templates: 2 hours
- Collaborative editing UI: 5 hours
- Clone feature: 3 hours
- Permission badges: 2 hours
- Analytics integration: 2 hours
- Expiry cron job: 3 hours
- Type definitions: 1 hour
- Security audit: 2.5 hours
- Integration testing: 5 hours

**Recommendation:** This story is complex and can be completed in 5-6 days by an experienced developer. Consider breaking into two stories if needed:
- Story 3.4a: Read-Only Sharing (25 hours)
- Story 3.4b: Edit Permissions & Clone (19 hours)

### Code Quality Checklist

Before marking story as "Review", Developer Agent MUST verify:

- [ ] No hardcoded colors (all use CSS variables)
- [ ] No hardcoded spacing (all use CSS variables)
- [ ] No `any` types in TypeScript
- [ ] All components under 250 lines
- [ ] All API routes under 200 lines
- [ ] All utility files under 150 lines
- [ ] Prisma migrations generated and committed
- [ ] API routes have comprehensive error handling
- [ ] All user inputs validated
- [ ] Access tokens are cryptographically secure
- [ ] Email service uses EU infrastructure
- [ ] GDPR compliance verified
- [ ] Rate limiting implemented
- [ ] Build succeeds with zero errors
- [ ] All imports use `@/` alias

## Definition of Done

- [ ] Database schema created for PageShare and PageCollaborator models
- [ ] Access token generation and verification utilities implemented
- [ ] Email service integrated with EU-based infrastructure
- [ ] Share management API endpoints created (list, create, update, delete)
- [ ] Access link validation middleware implemented
- [ ] ShareManagementModal component created and functional
- [ ] Invitation email templates created (HTML and plain text)
- [ ] Collaborative editing UI implemented
- [ ] Clone feature implemented and accessible
- [ ] Permission badges and visual indicators created
- [ ] Share analytics integrated into publish settings
- [ ] Expiry cron job configured and tested
- [ ] All type definitions added
- [ ] Security audit completed (no vulnerabilities)
- [ ] GDPR compliance verified
- [ ] All acceptance criteria met and tested
- [ ] Build succeeds with zero errors
- [ ] Code follows all CLAUDE.md standards
- [ ] Integration tests passing for all user flows
- [ ] Email delivery confirmed in test environment
- [ ] Documentation updated in Dev Notes

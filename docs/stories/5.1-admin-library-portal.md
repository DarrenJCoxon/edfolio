# Story 5.1: Admin Library Management Portal

**Epic:** Epic 5 - School-Wide Knowledge Library
**Status:** Not Started
**Estimated Effort:** 16-20 hours
**Priority:** High (Foundational)
**Dependencies:** Epic 4 Complete

---

## User Story

**As a school administrator**, I want to upload and manage documents in a centralized school library, so that all teachers in my school can access approved educational materials for their chatbots.

---

## Story Goal

Implement a complete multi-tenancy system with schools, role-based permissions, and an admin portal for uploading and managing institutional documents. This establishes the foundation for shared knowledge repositories at the school level.

---

## Acceptance Criteria

### School Management
- [ ] Super admin can create new schools
- [ ] Schools have name, domain, and settings
- [ ] School admin can update school settings
- [ ] School admin cannot delete school

### Member Management
- [ ] School admin can invite users by email
- [ ] Invited users receive email invitation
- [ ] Users can accept/decline invitation
- [ ] School admin can assign roles (admin, teacher, student)
- [ ] School admin can change member roles
- [ ] School admin can remove members
- [ ] Users can belong to multiple schools

### Document Upload
- [ ] School admin can upload documents to school library
- [ ] Same file types as personal upload (PDF, DOCX, TXT, MD)
- [ ] Maximum 10MB per file
- [ ] Documents processed identically to personal documents
- [ ] Documents have metadata (title, description, category)

### Document Management
- [ ] School admin can view all library documents
- [ ] Documents show filename, uploader, upload date, size, category
- [ ] School admin can edit document metadata
- [ ] School admin can delete documents
- [ ] School admin can categorize documents (Curriculum, Policy, Assessment, Other)

### Permission Enforcement
- [ ] All admin functions require school_admin role
- [ ] Teachers cannot access admin portal
- [ ] API endpoints enforce role-based permissions
- [ ] Audit logging for sensitive operations

---

## Dev Notes

### Database Schema

```prisma
model School {
  id              String          @id @default(cuid())
  name            String
  domain          String?         @unique
  settings        Json?
  members         SchoolMember[]
  library         SchoolDocument[]
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([domain])
}

model SchoolMember {
  id              String    @id @default(cuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  schoolId        String
  school          School    @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  role            String    // 'super_admin', 'school_admin', 'teacher', 'student'
  joinedAt        DateTime  @default(now())

  @@unique([userId, schoolId])
  @@index([schoolId])
  @@index([userId])
}

model SchoolDocument {
  id              String                @id @default(cuid())
  filename        String
  fileType        String
  fileSize        Int
  description     String?               @db.Text
  category        String?
  status          String                @default("processing")
  schoolId        String
  school          School                @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  uploadedById    String
  uploadedBy      User                  @relation(fields: [uploadedById], references: [id])
  chunks          SchoolDocumentChunk[]
  linkedChatbots  ChatbotSchoolDocLink[]
  uploadedAt      DateTime              @default(now())
  updatedAt       DateTime              @updatedAt

  @@index([schoolId])
  @@index([uploadedById])
  @@index([category])
}

model SchoolDocumentChunk {
  id              String         @id @default(cuid())
  documentId      String
  document        SchoolDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)
  content         String         @db.Text
  embedding       Unsupported("vector(384)")
  chunkIndex      Int
  tokenCount      Int

  @@index([documentId])
}

model AuditLog {
  id          String   @id @default(cuid())
  userId      String
  action      String
  resourceType String
  resourceId  String
  schoolId    String?
  metadata    Json?
  timestamp   DateTime @default(now())

  @@index([userId])
  @@index([schoolId])
  @@index([timestamp])
}
```

### Permission System

```typescript
// types/permissions.ts
export enum UserRole {
  SUPER_ADMIN = 'super_admin',
  SCHOOL_ADMIN = 'school_admin',
  TEACHER = 'teacher',
  STUDENT = 'student'
}

export type Permission =
  | 'school:create'
  | 'school:read'
  | 'school:update'
  | 'school:delete'
  | 'school:invite'
  | 'school:remove_member'
  | 'school_library:upload'
  | 'school_library:read'
  | 'school_library:update'
  | 'school_library:delete';

export const RolePermissions: Record<UserRole, Permission[]> = {
  [UserRole.SUPER_ADMIN]: [
    'school:create',
    'school:read',
    'school:update',
    'school:delete',
    'school:invite',
    'school:remove_member',
    'school_library:upload',
    'school_library:read',
    'school_library:update',
    'school_library:delete',
  ],
  [UserRole.SCHOOL_ADMIN]: [
    'school:read',
    'school:update',
    'school:invite',
    'school:remove_member',
    'school_library:upload',
    'school_library:read',
    'school_library:update',
    'school_library:delete',
  ],
  [UserRole.TEACHER]: [
    'school:read',
    'school_library:read',
  ],
  [UserRole.STUDENT]: [
    'school:read',
    'school_library:read',
  ],
};
```

```typescript
// lib/middleware/permissions.ts
import { getServerSession } from 'next-auth';
import { prisma } from '@/lib/prisma';
import { Permission, RolePermissions, UserRole } from '@/types/permissions';

export async function hasPermission(
  userId: string,
  schoolId: string,
  permission: Permission
): Promise<boolean> {
  const membership = await prisma.schoolMember.findUnique({
    where: {
      userId_schoolId: { userId, schoolId },
    },
  });

  if (!membership) return false;

  const userRole = membership.role as UserRole;
  const allowedPermissions = RolePermissions[userRole];

  return allowedPermissions.includes(permission);
}

export async function requirePermission(
  userId: string,
  schoolId: string,
  permission: Permission
) {
  const hasAccess = await hasPermission(userId, schoolId, permission);

  if (!hasAccess) {
    throw new Error('Forbidden: Insufficient permissions');
  }
}
```

### API Endpoints

**POST /api/schools** (Super Admin Only)
```typescript
// app/api/schools/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { prisma } from '@/lib/prisma';
import { z } from 'zod';

const createSchoolSchema = z.object({
  name: z.string().min(1).max(100),
  domain: z.string().optional(),
});

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Check if user is super admin (implement logic)
    const isSuperAdmin = await checkSuperAdmin(session.user.id);
    if (!isSuperAdmin) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    const body = await request.json();
    const validated = createSchoolSchema.parse(body);

    const school = await prisma.school.create({
      data: validated,
    });

    return NextResponse.json({ data: school }, { status: 201 });
  } catch (error) {
    console.error('Error creating school:', error);
    return NextResponse.json({ error: 'Failed to create school' }, { status: 500 });
  }
}
```

**POST /api/school-library/[schoolId]/upload**
```typescript
// app/api/school-library/[schoolId]/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { requirePermission } from '@/lib/middleware/permissions';
import { prisma } from '@/lib/prisma';
import { extractText, chunkText } from '@/lib/document-processor';
import { generateBatchEmbeddings } from '@/lib/embeddings';
import { logAudit } from '@/lib/audit';

export async function POST(
  request: NextRequest,
  { params }: { params: { schoolId: string } }
) {
  try {
    const session = await getServerSession();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { schoolId } = params;

    // Check permission
    await requirePermission(
      session.user.id,
      schoolId,
      'school_library:upload'
    );

    const formData = await request.formData();
    const file = formData.get('file') as File;
    const description = formData.get('description') as string;
    const category = formData.get('category') as string;

    // Validate file
    if (file.size > 10 * 1024 * 1024) {
      return NextResponse.json({ error: 'File too large' }, { status: 400 });
    }

    // Create document record
    const document = await prisma.schoolDocument.create({
      data: {
        filename: file.name,
        fileType: file.type,
        fileSize: file.size,
        description,
        category,
        schoolId,
        uploadedById: session.user.id,
        status: 'processing',
      },
    });

    // Log audit
    await logAudit({
      userId: session.user.id,
      action: 'upload_school_document',
      resourceType: 'school_document',
      resourceId: document.id,
      schoolId,
    });

    // Process document asynchronously
    processSchoolDocument(document.id, file);

    return NextResponse.json({ data: document }, { status: 201 });
  } catch (error) {
    console.error('Error uploading document:', error);
    return NextResponse.json({ error: 'Upload failed' }, { status: 500 });
  }
}

async function processSchoolDocument(documentId: string, file: File) {
  // Same processing as personal documents
  const text = await extractText(file);
  const chunks = chunkText(text);
  const embeddings = await generateBatchEmbeddings(chunks);

  const chunkData = chunks.map((content, index) => ({
    documentId,
    content,
    embedding: embeddings[index],
    chunkIndex: index,
    tokenCount: encode(content).length,
  }));

  await prisma.schoolDocumentChunk.createMany({
    data: chunkData,
  });

  await prisma.schoolDocument.update({
    where: { id: documentId },
    data: { status: 'completed' },
  });
}
```

### Component Structure
```
components/school/
├── SchoolAdminPortal.tsx        # Main admin interface
├── SchoolLibraryBrowser.tsx     # View all documents
├── SchoolDocumentUpload.tsx     # Upload interface
├── SchoolDocumentCard.tsx       # Document display
├── SchoolMemberManagement.tsx   # Manage members
├── MemberInviteModal.tsx        # Invite form
└── SchoolSettings.tsx           # School config
```

---

## Tasks

1. **Database Schema** (2 hours)
   - [ ] Add School, SchoolMember, SchoolDocument models
   - [ ] Add SchoolDocumentChunk and AuditLog models
   - [ ] Create migrations
   - [ ] Test locally

2. **Permission System** (3 hours)
   - [ ] Create `types/permissions.ts`
   - [ ] Create `lib/middleware/permissions.ts`
   - [ ] Implement role checking
   - [ ] Add audit logging utility

3. **School Management API** (4 hours)
   - [ ] Create `/api/schools` endpoints
   - [ ] Create `/api/schools/[id]` endpoints
   - [ ] Create `/api/schools/[id]/members` endpoints
   - [ ] Implement invitation system

4. **School Library API** (4 hours)
   - [ ] Create `/api/school-library/[schoolId]/upload`
   - [ ] Create `/api/school-library/[schoolId]` (GET, list)
   - [ ] Create `/api/school-library/[schoolId]/documents/[docId]` (GET, PUT, DELETE)
   - [ ] Reuse document processing from Epic 3

5. **Admin Portal UI** (5 hours)
   - [ ] Create SchoolAdminPortal layout
   - [ ] Create document upload interface
   - [ ] Create document list with filtering
   - [ ] Create member management interface
   - [ ] Add invitation UI

6. **Testing** (2 hours)
   - [ ] Test permission system
   - [ ] Test document upload
   - [ ] Test member management
   - [ ] Test audit logging

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Multi-tenancy working
- [ ] Permissions enforced
- [ ] Documents upload successfully
- [ ] Members can be invited
- [ ] Audit logs created
- [ ] Code follows CLAUDE.md standards

---

**Next Story:** 4.2 - Teacher Access to School Library

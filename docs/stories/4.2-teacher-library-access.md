# Story 4.2: Teacher Access to School Library

**Epic:** Epic 4 - School-Wide Knowledge Library
**Status:** Not Started
**Estimated Effort:** 10-12 hours
**Priority:** High
**Dependencies:** Story 4.1

---

## User Story

**As a teacher**, I want to browse my school's library and link approved documents to my chatbots, so that my AI assistants have access to institutional knowledge without me needing to upload the same documents multiple times.

---

## Story Goal

Enable teachers to view the school library, search and filter documents, and link/unlink school documents to their personal chatbots. Teachers maintain full control over which school materials their chatbots use.

---

## Acceptance Criteria

### Library Browsing
- [ ] Teacher can access school library from main navigation
- [ ] Library shows all school documents (read-only)
- [ ] Documents display filename, category, upload date, description
- [ ] Teacher can search by filename or description
- [ ] Teacher can filter by category
- [ ] Teacher can sort by date, name, category

### Document Preview
- [ ] Teacher can click document to view details
- [ ] Detail view shows full metadata
- [ ] Detail view shows uploader and upload date
- [ ] Teacher cannot edit or delete school documents
- [ ] Preview shows document type and size

### Linking Documents
- [ ] Each document has "Link to Chatbot" button
- [ ] Button opens chatbot selector modal
- [ ] Teacher can select one or more chatbots
- [ ] Link action creates ChatbotSchoolDocLink records
- [ ] Success notification shown
- [ ] Document shows "Linked" badge for teacher's chatbots

### Managing Links
- [ ] Teacher can view which documents are linked to each chatbot
- [ ] Chatbot configuration shows linked school documents separately from personal docs
- [ ] Teacher can unlink school documents from their chatbots
- [ ] Unlinking does not affect other teachers
- [ ] Linked documents do not count toward personal storage quota

### Automatic Updates
- [ ] If school admin updates document, changes propagate immediately
- [ ] If school admin deletes document, links are automatically removed
- [ ] Teacher receives notification of document changes/removals

---

## Dev Notes

### Database Extension

```prisma
model ChatbotSchoolDocLink {
  id              String         @id @default(cuid())
  chatbotId       String
  chatbot         Chatbot        @relation(fields: [chatbotId], references: [id], onDelete: Cascade)
  documentId      String
  document        SchoolDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)
  linkedAt        DateTime       @default(now())

  @@unique([chatbotId, documentId])
  @@index([chatbotId])
  @@index([documentId])
}

// Extend Chatbot model
model Chatbot {
  // ... existing fields
  linkedSchoolDocs ChatbotSchoolDocLink[]
}
```

### API Endpoints

**GET /api/school-library/[schoolId]** (Teacher Access)
```typescript
// app/api/school-library/[schoolId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { hasPermission } from '@/lib/middleware/permissions';
import { prisma } from '@/lib/prisma';

export async function GET(
  request: NextRequest,
  { params }: { params: { schoolId: string } }
) {
  try {
    const session = await getServerSession();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { schoolId } = params;
    const { searchParams } = new URL(request.url);
    const category = searchParams.get('category');
    const search = searchParams.get('search');

    // Check permission
    const hasAccess = await hasPermission(
      session.user.id,
      schoolId,
      'school_library:read'
    );

    if (!hasAccess) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
    }

    // Build query
    const where: any = { schoolId, status: 'completed' };
    if (category) where.category = category;
    if (search) {
      where.OR = [
        { filename: { contains: search, mode: 'insensitive' } },
        { description: { contains: search, mode: 'insensitive' } },
      ];
    }

    const documents = await prisma.schoolDocument.findMany({
      where,
      include: {
        uploadedBy: {
          select: { email: true },
        },
        linkedChatbots: {
          where: {
            chatbot: { userId: session.user.id },
          },
        },
      },
      orderBy: { uploadedAt: 'desc' },
    });

    return NextResponse.json({ data: documents });
  } catch (error) {
    console.error('Error fetching library:', error);
    return NextResponse.json({ error: 'Failed to fetch library' }, { status: 500 });
  }
}
```

**POST /api/chatbots/[chatbotId]/school-links**
```typescript
// app/api/chatbots/[chatbotId]/school-links/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { prisma } from '@/lib/prisma';
import { logAudit } from '@/lib/audit';

export async function POST(
  request: NextRequest,
  { params }: { params: { chatbotId: string } }
) {
  try {
    const session = await getServerSession();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { chatbotId } = params;
    const { documentId } = await request.json();

    // Verify chatbot ownership
    const chatbot = await prisma.chatbot.findFirst({
      where: { id: chatbotId, userId: session.user.id },
    });

    if (!chatbot) {
      return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
    }

    // Verify document access (user must be in school)
    const document = await prisma.schoolDocument.findFirst({
      where: { id: documentId },
      include: { school: { include: { members: true } } },
    });

    if (!document) {
      return NextResponse.json({ error: 'Document not found' }, { status: 404 });
    }

    const isMember = document.school.members.some(
      (m) => m.userId === session.user.id
    );

    if (!isMember) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 });
    }

    // Create link
    const link = await prisma.chatbotSchoolDocLink.create({
      data: {
        chatbotId,
        documentId,
      },
    });

    // Audit log
    await logAudit({
      userId: session.user.id,
      action: 'link_school_document',
      resourceType: 'chatbot_school_doc_link',
      resourceId: link.id,
      schoolId: document.schoolId,
      metadata: { chatbotId, documentId },
    });

    return NextResponse.json({ data: link }, { status: 201 });
  } catch (error) {
    console.error('Error linking document:', error);
    return NextResponse.json({ error: 'Failed to link document' }, { status: 500 });
  }
}

export async function GET(
  request: NextRequest,
  { params }: { params: { chatbotId: string } }
) {
  try {
    const session = await getServerSession();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { chatbotId } = params;

    // Verify ownership
    const chatbot = await prisma.chatbot.findFirst({
      where: { id: chatbotId, userId: session.user.id },
      include: {
        linkedSchoolDocs: {
          include: {
            document: true,
          },
        },
      },
    });

    if (!chatbot) {
      return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
    }

    return NextResponse.json({ data: chatbot.linkedSchoolDocs });
  } catch (error) {
    console.error('Error fetching links:', error);
    return NextResponse.json({ error: 'Failed to fetch links' }, { status: 500 });
  }
}
```

### Component Structure

```
components/school/
├── SchoolLibraryBrowser.tsx     # Main library view (teacher version)
├── SchoolDocumentCard.tsx       # Document card with link button
├── DocumentDetailModal.tsx      # Full document details
├── LinkChatbotModal.tsx         # Select chatbots to link
└── LinkedDocumentBadge.tsx      # Visual indicator

components/chatbot/
├── KnowledgeBaseManager.tsx     # Updated to show school docs
├── SchoolDocumentsList.tsx      # List of linked school docs
└── UnlinkDocumentButton.tsx     # Unlink action
```

---

## Tasks

1. **Database Schema** (1 hour)
   - [ ] Add ChatbotSchoolDocLink model
   - [ ] Update Chatbot model with relation
   - [ ] Create migration

2. **API - Library Access** (2 hours)
   - [ ] Update `/api/school-library/[schoolId]` for teachers
   - [ ] Add search and filter logic
   - [ ] Include link status in response

3. **API - Linking** (3 hours)
   - [ ] Create `/api/chatbots/[chatbotId]/school-links` (POST)
   - [ ] Create GET endpoint for linked docs
   - [ ] Create DELETE endpoint for unlinking
   - [ ] Add permission checks

4. **Library Browser UI** (3 hours)
   - [ ] Create teacher library view
   - [ ] Add search and filter UI
   - [ ] Add document cards
   - [ ] Add link buttons

5. **Linking UI** (2 hours)
   - [ ] Create chatbot selector modal
   - [ ] Show linked documents in chatbot config
   - [ ] Add unlink functionality

6. **Testing** (1 hour)
   - [ ] Test linking flow
   - [ ] Test permissions
   - [ ] Test cross-teacher isolation

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Teachers can browse library
- [ ] Linking/unlinking works
- [ ] Permissions enforced
- [ ] School docs separated from personal docs
- [ ] Code follows CLAUDE.md standards

---

**Next Story:** 4.3 - Grounded Chat with School Knowledge
